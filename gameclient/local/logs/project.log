2022-07-08 13:36:43-log: [Package] menu@1.0.0 enable
2022-07-08 13:36:43-log: [Package] profile@1.0.0 enable
2022-07-08 13:36:43-log: [Package] project@1.0.1 enable
2022-07-08 13:36:43-log: [Package] messages@1.0.0 enable
2022-07-08 13:36:43-log: [Package] program@1.0.0 enable
2022-07-08 13:36:43-log: [Package] device@1.0.1 enable
2022-07-08 13:36:43-log: [Package] ui-kit@1.0.1 enable
2022-07-08 13:36:43-log: [Package] tester@1.0.0 enable
2022-07-08 13:36:43-log: [Package] preferences@1.0.0 enable
2022-07-08 13:36:44-log: Setup mods mgr.: 178.972ms
2022-07-08 13:36:44-log: [Package] engine@1.0.5 enable
2022-07-08 13:36:45-log: [Package] programming@1.0.0 enable
2022-07-08 13:36:45-log: [Package] engine-extends@1.0.0 enable
2022-07-08 13:36:45-log: [Package] asset-db@1.0.0 enable
2022-07-08 13:36:45-log: [Package] console@1.0.0 enable
2022-07-08 13:36:45-log: [Package] scene@1.0.0 enable
2022-07-08 13:36:45-log: [Package] about@1.0.0 enable
2022-07-08 13:36:45-log: [Package] server@1.0.0 enable
2022-07-08 13:36:45-log: [Package] utils@1.0.0 enable
2022-07-08 13:36:46-log: [Package] assets@1.0.0 enable
2022-07-08 13:36:46-log: [Package] inspector@1.0.0 enable
2022-07-08 13:36:46-log: [Package] hierarchy@1.0.0 enable
2022-07-08 13:36:46-log: [Package] preview@1.0.1 enable
2022-07-08 13:36:46-log: [Package] animator@1.0.0 enable
2022-07-08 13:36:47-log: [Package] builder@1.3.0 enable
2022-07-08 13:36:47-log: [Package] node-library@1.0.0 enable
2022-07-08 13:36:47-log: [Package] shortcuts@1.0.1 enable
2022-07-08 13:36:47-log: [Package] package-asset@1.0.0 enable
2022-07-08 13:36:47-log: [Package] reference-image@1.0.0 enable
2022-07-08 13:36:47-log: [Package] animation-graph@1.0.0 enable
2022-07-08 13:36:47-log: [Package] channel-upload-tools@1.0.0 enable
2022-07-08 13:36:47-log: [Package] runtime-dev-tools@1.0.0 enable
2022-07-08 13:36:47-log: [Package] lightmap@1.0.4 enable
2022-07-08 13:36:47-log: [Package] alipay-mini-game@1.0.0 enable
2022-07-08 13:36:47-log: [Package] android@1.0.0 enable
2022-07-08 13:36:47-log: [Package] baidu-mini-game@1.0.0 enable
2022-07-08 13:36:47-log: [Package] bytedance-mini-game@1.0.1 enable
2022-07-08 13:36:47-log: [Package] huawei-agc@1.0.0 enable
2022-07-08 13:36:47-log: [Package] ios@1.0.0 enable
2022-07-08 13:36:47-log: [Package] ios-app-clip@1.0.0 enable
2022-07-08 13:36:47-log: [Package] mac@1.0.0 enable
2022-07-08 13:36:47-log: [Package] native@1.0.0 enable
2022-07-08 13:36:47-log: [Package] ohos@1.0.0 enable
2022-07-08 13:36:47-log: [Package] web-desktop@1.0.0 enable
2022-07-08 13:36:47-log: [Package] web-mobile@1.0.0 enable
2022-07-08 13:36:47-log: [Package] wechatgame@1.0.1 enable
2022-07-08 13:36:47-log: [Package] windows@1.0.0 enable
2022-07-08 13:36:47-log: [Package] xiaomi-quick-game@1.0.0 enable
2022-07-08 13:36:47-log: [Package] cocos-play@1.0.0 enable
2022-07-08 13:36:47-log: [Package] huawei-quick-game@1.0.0 enable
2022-07-08 13:36:48-log: [Package] link-sure@1.0.0 enable
2022-07-08 13:36:48-log: [Package] oppo-mini-game@1.0.0 enable
2022-07-08 13:36:48-log: [Package] qtt@1.0.0 enable
2022-07-08 13:36:48-log: [Package] vivo-mini-game@1.0.0 enable
2022-07-08 13:36:48-log: [Package] cocos-service@3.0.2 enable
2022-07-08 13:36:48-log: [Package] importer@1.0.0 enable
2022-07-08 13:36:48-log: [Package] extension@3.0.13 enable
2022-07-08 13:36:48-log: [Im-plugin] Check im-plugin version.
2022-07-08 13:36:48-log: [Package] im-plugin@3.0.8 enable
2022-07-08 13:36:48-warn: Browserslist: caniuse-lite is outdated. Please run:
npx browserslist@latest --update-db

Why you should do it regularly:
https://github.com/browserslist/browserslist#browsers-data-updating
2022-07-08 13:36:48-log: [Scene] begin init
2022-07-08 13:36:48-log: [Scene] require engine end
2022-07-08 13:36:48-log: [Scene] Serialize end
2022-07-08 13:36:48-log: [Scene] configureStartup end
2022-07-08 13:36:48-log: [Scene] Cocos Creator v3.4.0
2022-07-08 13:36:48-info: [Scene] Forward render pipeline initialized.
2022-07-08 13:36:49-log: [Scene] openEngine end
2022-07-08 13:36:49-log: [Scene] configureEngine end
2022-07-08 13:36:49-error: [Scene] FragmentShader in 'builtin-standard|standard-vs|standard-fs|CC_USE_FOG4|CC_USE_HDR1' compilation failed.
2022-07-08 13:36:49-error: [Scene] Shader source dump: 
1 #define CC_DEVICE_SUPPORT_FLOAT_TEXTURE 1
2 #define CC_ENABLE_CLUSTERED_LIGHT_CULLING 0
3 #define CC_DEVICE_MAX_VERTEX_UNIFORM_VECTORS 4095
4 #define CC_DEVICE_MAX_FRAGMENT_UNIFORM_VECTORS 1024
5 #define CC_DEVICE_CAN_BENEFIT_FROM_INPUT_ATTACHMENT 0
6 #define CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS 223
7 #define CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS 75
8 #define USE_INSTANCING 0
9 #define USE_BATCHING 0
10 #define CC_USE_SKINNING 0
11 #define CC_USE_BAKED_ANIMATION 0
12 #define CC_USE_LIGHTMAP 0
13 #define CC_RECEIVE_SHADOW 0
14 #define CC_USE_MORPH 0
15 #define CC_MORPH_TARGET_COUNT 2
16 #define CC_MORPH_PRECOMPUTED 0
17 #define CC_MORPH_TARGET_HAS_POSITION 0
18 #define CC_MORPH_TARGET_HAS_NORMAL 0
19 #define CC_MORPH_TARGET_HAS_TANGENT 0
20 #define CC_USE_FOG 4
21 #define CC_USE_ACCURATE_FOG 0
22 #define USE_VERTEX_COLOR 0
23 #define HAS_SECOND_UV 0
24 #define USE_NORMAL_MAP 0
25 #define CC_FORWARD_ADD 0
26 #define USE_TWOSIDE 0
27 #define SAMPLE_FROM_RT 0
28 #define CC_USE_IBL 0
29 #define CC_USE_DIFFUSEMAP 0
30 #define USE_REFLECTION_DENOISE 0
31 #define CC_USE_HDR 1
32 #define USE_ALBEDO_MAP 0
33 #define ALBEDO_UV v_uv
34 #define NORMAL_UV v_uv
35 #define PBR_UV v_uv
36 #define USE_PBR_MAP 0
37 #define USE_METALLIC_ROUGHNESS_MAP 0
38 #define USE_OCCLUSION_MAP 0
39 #define USE_EMISSIVE_MAP 0
40 #define EMISSIVE_UV v_uv
41 #define USE_ALPHA_TEST 0
42 #define ALPHA_TEST_CHANNEL a
43 #define CC_PIPELINE_TYPE 0
44 #define CC_FORCE_FORWARD_SHADING 0
45 
46 precision highp float;
47 layout(std140) uniform CCGlobal {
48   highp   vec4 cc_time;
49   mediump vec4 cc_screenSize;
50   mediump vec4 cc_nativeSize;
51 };
52 layout(std140) uniform CCCamera {
53   highp   mat4 cc_matView;
54   highp   mat4 cc_matViewInv;
55   highp   mat4 cc_matProj;
56   highp   mat4 cc_matProjInv;
57   highp   mat4 cc_matViewProj;
58   highp   mat4 cc_matViewProjInv;
59   highp   vec4 cc_cameraPos;
60   mediump vec4 cc_screenScale;
61   mediump vec4 cc_exposure;
62   mediump vec4 cc_mainLitDir;
63   mediump vec4 cc_mainLitColor;
64   mediump vec4 cc_ambientSky;
65   mediump vec4 cc_ambientGround;
66   mediump vec4 cc_fogColor;
67   mediump vec4 cc_fogBase;
68   mediump vec4 cc_fogAdd;
69   mediump vec4 cc_nearFar;
70   mediump vec4 cc_viewPort;
71 };
72 layout(std140) uniform Constants {
73   vec4 tilingOffset;
74   vec4 albedo;
75   vec4 albedoScaleAndCutoff;
76   vec4 pbrParams;
77   vec4 emissive;
78   vec4 emissiveScaleParam;
79 };
80 float LinearFog(vec4 pos) {
81   vec4 wPos = pos;
82   float cam_dis = distance(cc_cameraPos, wPos);
83   float fogStart = cc_fogBase.x;
84   float fogEnd = cc_fogBase.y;
85   return clamp((fogEnd - cam_dis) / (fogEnd - fogStart), 0., 1.);
86 }
87 float ExpFog(vec4 pos) {
88   vec4 wPos = pos;
89   float fogAtten = cc_fogAdd.z;
90   float fogStart = cc_fogBase.x;
91   float fogDensity = cc_fogBase.z;
92   float cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;
93   float f = exp(-cam_dis * fogDensity);
94   return f;
95 }
96 float ExpSquaredFog(vec4 pos) {
97   vec4 wPos = pos;
98   float fogAtten = cc_fogAdd.z;
99   float fogStart = cc_fogBase.x;
100   float fogDensity = cc_fogBase.z;
101   float cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;
102   float f = exp(-cam_dis * cam_dis * fogDensity * fogDensity);
103   return f;
104 }
105 float LayeredFog(vec4 pos) {
106   vec4 wPos = pos;
107   float fogAtten = cc_fogAdd.z;
108   float _FogTop = cc_fogAdd.x;
109   float _FogRange = cc_fogAdd.y;
110   vec3 camWorldProj = cc_cameraPos.xyz;
111   camWorldProj.y = 0.;
112   vec3 worldPosProj = wPos.xyz;
113   worldPosProj.y = 0.;
114   float fDeltaD = distance(worldPosProj, camWorldProj) / fogAtten * 2.0;
115   float fDeltaY, fDensityIntegral;
116   if (cc_cameraPos.y > _FogTop) {
117     if (wPos.y < _FogTop) {
118       fDeltaY = (_FogTop - wPos.y) / _FogRange * 2.0;
119       fDensityIntegral = fDeltaY * fDeltaY * 0.5;
120     } else {
121       fDeltaY = 0.;
122       fDensityIntegral = 0.;
123     }
124   } else {
125     if (wPos.y < _FogTop) {
126       float fDeltaA = (_FogTop - cc_cameraPos.y) / _FogRange * 2.;
127       float fDeltaB = (_FogTop - wPos.y) / _FogRange * 2.;
128       fDeltaY = abs(fDeltaA - fDeltaB);
129       fDensityIntegral = abs((fDeltaA * fDeltaA * 0.5) - (fDeltaB * fDeltaB * 0.5));
130     } else {
131       fDeltaY = abs(_FogTop - cc_cameraPos.y) / _FogRange * 2.;
132       fDensityIntegral = abs(fDeltaY * fDeltaY * 0.5);
133     }
134   }
135   float fDensity;
136   if (fDeltaY != 0.) {
137     fDensity = (sqrt(1.0 + ((fDeltaD / fDeltaY) * (fDeltaD / fDeltaY)))) * fDensityIntegral;
138   } else {
139     fDensity = 0.;
140   }
141   float f = exp(-fDensity);
142   return f;
143 }
144 void CC_TRANSFER_FOG_BASE(vec4 pos, out float factor)
145 {
146   #if CC_USE_FOG == 0
147 	factor = LinearFog(pos);
148   #elif CC_USE_FOG == 1
149     factor = ExpFog(pos);
150   #elif CC_USE_FOG == 2
151     factor = ExpSquaredFog(pos);
152   #elif CC_USE_FOG == 3
153     factor = LayeredFog(pos);
154   #else
155     factor = 1.0;
156   #endif
157 }
158 void CC_APPLY_FOG_BASE(inout vec4 color, float factor) {
159   color = vec4(mix(cc_fogColor.rgb, color.rgb, factor), color.a);
160 }
161 #if !CC_USE_ACCURATE_FOG
162 in float v_fog_factor;
163 #endif
164 void CC_APPLY_FOG(inout vec4 color) {
165 #if !CC_USE_ACCURATE_FOG
166     CC_APPLY_FOG_BASE(color, v_fog_factor);
167 #endif
168 }
169 void CC_APPLY_FOG(inout vec4 color, vec3 worldPos) {
170 #if CC_USE_ACCURATE_FOG
171     float factor;
172     CC_TRANSFER_FOG_BASE(vec4(worldPos, 1.0), factor);
173 #else
174     float factor = v_fog_factor;
175 #endif
176     CC_APPLY_FOG_BASE(color, factor);
177 }
178 #define QUATER_PI         0.78539816340
179 #define HALF_PI           1.57079632679
180 #define PI                3.14159265359
181 #define PI2               6.28318530718
182 #define PI4               12.5663706144
183 #define INV_QUATER_PI     1.27323954474
184 #define INV_HALF_PI       0.63661977237
185 #define INV_PI            0.31830988618
186 #define INV_PI2           0.15915494309
187 #define INV_PI4           0.07957747155
188 #define EPSILON           1e-6
189 #define EPSILON_LOWP      1e-4
190 #define LOG2              1.442695
191 #define EXP_VALUE         2.71828183f
192 #define FP_MAX            65504.0
193 #define FP_SCALE          0.0009765625
194 #define FP_SCALE_INV      1024.0
195 #define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)
196 vec3 SRGBToLinear (vec3 gamma) {
197   return gamma * gamma;
198 }
199 layout(std140) uniform CCShadow {
200   highp mat4 cc_matLightPlaneProj;
201   highp mat4 cc_matLightView;
202   highp mat4 cc_matLightViewProj;
203   highp vec4 cc_shadowInvProjDepthInfo;
204   highp vec4 cc_shadowProjDepthInfo;
205   highp vec4 cc_shadowProjInfo;
206   mediump vec4 cc_shadowNFLSInfo;
207   mediump vec4 cc_shadowWHPBInfo;
208   mediump vec4 cc_shadowLPNNInfo;
209   lowp vec4 cc_shadowColor;
210   mediump vec4 cc_planarNDInfo;
211 };
212 highp float unpackHighpData (float mainPart, float modPart) {
213   highp float data = mainPart;
214   return data + modPart;
215 }
216 void packHighpData (out float mainPart, out float modPart, highp float data) {
217   mainPart = fract(data);
218   modPart = data - mainPart;
219 }
220 highp float unpackHighpData (float mainPart, float modPart, const float modValue) {
221   highp float data = mainPart * modValue;
222   return data + modPart * modValue;
223 }
224 void packHighpData (out float mainPart, out float modPart, highp float data, const float modValue) {
225   highp float divide = data / modValue;
226   mainPart = floor(divide);
227   modPart = (data - mainPart * modValue) / modValue;
228 }
229 highp vec2 unpackHighpData (vec2 mainPart, vec2 modPart) {
230   highp vec2 data = mainPart;
231   return data + modPart;
232 }
233 void packHighpData (out vec2 mainPart, out vec2 modPart, highp vec2 data) {
234   mainPart = fract(data);
235   modPart = data - mainPart;
236 }
237 highp vec2 unpackHighpData (vec2 mainPart, vec2 modPart, const float modValue) {
238   highp vec2 data = mainPart * modValue;
239   return data + modPart * modValue;
240 }
241 void packHighpData (out vec2 mainPart, out vec2 modPart, highp vec2 data, const float modValue) {
242   highp vec2 divide = data / modValue;
243   mainPart = floor(divide);
244   modPart = (data - mainPart * modValue) / modValue;
245 }
246 highp vec3 unpackHighpData (vec3 mainPart, vec3 modPart) {
247   highp vec3 data = mainPart;
248   return data + modPart;
249 }
250 void packHighpData (out vec3 mainPart, out vec3 modPart, highp vec3 data) {
251   mainPart = fract(data);
252   modPart = data - mainPart;
253 }
254 highp vec3 unpackHighpData (vec3 mainPart, vec3 modPart, const float modValue) {
255   highp vec3 data = mainPart * modValue;
256   return data + modPart * modValue;
257 }
258 void packHighpData (out vec3 mainPart, out vec3 modPart, highp vec3 data, const float modValue) {
259   highp vec3 divide = data / modValue;
260   mainPart = floor(divide);
261   modPart = (data - mainPart * modValue) / modValue;
262 }
263 highp vec4 unpackHighpData (vec4 mainPart, vec4 modPart) {
264   highp vec4 data = mainPart;
265   return data + modPart;
266 }
267 void packHighpData (out vec4 mainPart, out vec4 modPart, highp vec4 data) {
268   mainPart = fract(data);
269   modPart = data - mainPart;
270 }
271 highp vec4 unpackHighpData (vec4 mainPart, vec4 modPart, const float modValue) {
272   highp vec4 data = mainPart * modValue;
273   return data + modPart * modValue;
274 }
275 void packHighpData (out vec4 mainPart, out vec4 modPart, highp vec4 data, const float modValue) {
276   highp vec4 divide = data / modValue;
277   mainPart = floor(divide);
278   modPart = (data - mainPart * modValue) / modValue;
279 }
280 layout(std140) uniform CCLocal {
281   highp mat4 cc_matWorld;
282   highp mat4 cc_matWorldIT;
283   highp vec4 cc_lightingMapUVParam;
284   highp vec4 cc_localShadowBias;
285 };
286 float CCGetLinearDepthFromViewSpace(vec3 viewPos) {
287   float dist = length(viewPos);
288   return (dist - cc_shadowNFLSInfo.x) / (cc_shadowNFLSInfo.y - cc_shadowNFLSInfo.x);
289 }
290 float CCGetLinearDepth(vec3 worldPos) {
291   vec4 viewStartPos = cc_matLightView * vec4(worldPos.xyz, 1.0);
292   return CCGetLinearDepthFromViewSpace(viewStartPos.xyz);
293 }
294 #if CC_RECEIVE_SHADOW
295   uniform highp sampler2D cc_shadowMap;
296   uniform highp sampler2D cc_spotLightingMap;
297   vec4 ApplyShadowDepthBias_FaceNormal(vec4 shadowPos, vec3 worldNormal, float normalBias)
298   {
299     vec4 newShadowPos = shadowPos;
300     if(normalBias > EPSILON_LOWP)
301     {
302       vec4 viewNormal = cc_matLightView * vec4(worldNormal, 0.0);
303       if(viewNormal.z < 0.1)
304         newShadowPos.xy += viewNormal.xy * cc_shadowProjInfo.xy * normalBias * clamp(viewNormal.z, 0.001, 0.1);
305     }
306     return newShadowPos;
307   }
308   vec4 ApplyShadowDepthBias_Perspective(vec4 shadowPos, float viewspaceDepthBias)
309   {
310     vec3 viewSpacePos;
311     viewSpacePos.xy = shadowPos.xy * cc_shadowProjInfo.zw;
312     viewSpacePos.z = shadowPos.z * cc_shadowInvProjDepthInfo.x + shadowPos.w * cc_shadowInvProjDepthInfo.y;
313     viewSpacePos.xyz += cc_shadowProjDepthInfo.z * normalize(viewSpacePos.xyz) * viewspaceDepthBias;
314     vec4 clipSpacePos;
315     clipSpacePos.xy = viewSpacePos.xy * cc_shadowProjInfo.xy;
316     clipSpacePos.zw = viewSpacePos.z * cc_shadowProjDepthInfo.xz + vec2(cc_shadowProjDepthInfo.y, 0.0);
317     if (cc_shadowNFLSInfo.z > EPSILON) {
318       clipSpacePos.z = CCGetLinearDepthFromViewSpace(viewSpacePos.xyz);
319       clipSpacePos.z = (clipSpacePos.z * 2.0 - 1.0) * clipSpacePos.w;
320     }
321     return clipSpacePos;
322   }
323   vec4 ApplyShadowDepthBias_Orthographic(vec4 shadowPos, float viewspaceDepthBias)
324   {
325     float coeffA = cc_shadowProjDepthInfo.x;
326     float coeffB = cc_shadowProjDepthInfo.y;
327     float viewSpacePos_z = (shadowPos.z - coeffB) / coeffA;
328     viewSpacePos_z += viewspaceDepthBias;
329     vec4 result = shadowPos;
330     result.z = viewSpacePos_z * coeffA + coeffB;
331     return result;
332   }
333   float CCGetShadowFactorHard (vec4 shadowPos, float bias) {
334     vec4 clipPosNew = ApplyShadowDepthBias_Orthographic(shadowPos, bias);
335     vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;
336     if (clipPos.x < 0.0 || clipPos.x > 1.0 ||
337         clipPos.y < 0.0 || clipPos.y > 1.0 ||
338         clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }
339     clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;
340     float shadow = 0.0;
341     float closestDepth = 0.0;
342     if (cc_shadowLPNNInfo.y > EPSILON) {
343       closestDepth = dot(texture(cc_shadowMap, clipPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0));
344     } else {
345       closestDepth = texture(cc_shadowMap, clipPos.xy).x;
346     }
347     shadow = step(clipPos.z, closestDepth);
348     return shadow;
349   }
350   float CCGetShadowFactorSoft (vec4 shadowPos, float bias) {
351     vec4 clipPosNew = ApplyShadowDepthBias_Orthographic(shadowPos, bias);
352     vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;
353     if (clipPos.x < 0.0 || clipPos.x > 1.0 ||
354         clipPos.y < 0.0 || clipPos.y > 1.0 ||
355         clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }
356     clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;
357     float offsetDepth = clipPos.z;
358     vec2 mapSize = cc_shadowWHPBInfo.xy;
359     vec2 oneTap = 1.0 / mapSize;
360     vec2 clipPos_offset = clipPos.xy + oneTap;
361     float block0, block1, block2, block3;
362     if (cc_shadowLPNNInfo.y > EPSILON) {
363       block0 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));
364       block1 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));
365       block2 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));
366       block3 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));
367     } else {
368       block0 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos.x, clipPos.y)).x);
369       block1 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset.x, clipPos.y)).x);
370       block2 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset.y)).x);
371       block3 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset.x, clipPos_offset.y)).x);
372     }
373     float coefX   = mod(clipPos.x, oneTap.x) * mapSize.x;
374     float resultX = mix(block0, block1, coefX);
375     float resultY = mix(block2, block3, coefX);
376     float coefY   = mod(clipPos.y, oneTap.y) * mapSize.y;
377     return mix(resultX, resultY, coefY);
378   }
379   float CCGetShadowFactorSoft2X (vec4 shadowPos, float bias) {
380     vec4 clipPosNew = ApplyShadowDepthBias_Orthographic(shadowPos, bias);
381     vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;
382     if (clipPos.x < 0.0 || clipPos.x > 1.0 ||
383         clipPos.y < 0.0 || clipPos.y > 1.0 ||
384         clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }
385     clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;
386     float offsetDepth = clipPos.z;
387     vec2 mapSize = cc_shadowWHPBInfo.xy;
388     vec2 oneTap = 1.0 / mapSize;
389     float clipPos_offset_L = clipPos.x - oneTap.x;
390     float clipPos_offset_R = clipPos.x + oneTap.x;
391     float clipPos_offset_U = clipPos.y - oneTap.y;
392     float clipPos_offset_D = clipPos.y + oneTap.y;
393     float block0, block1, block2, block3, block4, block5, block6, block7, block8;
394     if (cc_shadowLPNNInfo.y > EPSILON) {
395       block0 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));
396       block1 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));
397       block2 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));
398       block3 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));
399       block4 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));
400       block5 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));
401       block6 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));
402       block7 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));
403       block8 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));
404     } else {
405       block0 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_U)).x);
406       block1 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset_U)).x);
407       block2 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_U)).x);
408       block3 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos.y)).x);
409       block4 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos.x, clipPos.y)).x);
410       block5 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos.y)).x);
411       block6 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_D)).x);
412       block7 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset_D)).x);
413       block8 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_D)).x);
414     }
415     float coefX = mod(clipPos.x, oneTap.x) * mapSize.x;
416     float coefY = mod(clipPos.y, oneTap.y) * mapSize.y;
417     float shadow = 0.0;
418     float resultX = mix(block0, block1, coefX);
419     float resultY = mix(block3, block4, coefX);
420     shadow += mix(resultX , resultY, coefY);
421     resultX = mix(block1, block2, coefX);
422     resultY = mix(block4, block5, coefX);
423     shadow += mix(resultX , resultY, coefY);
424     resultX = mix(block3, block4, coefX);
425     resultY = mix(block6, block7, coefX);
426     shadow += mix(resultX, resultY, coefY);
427     resultX = mix(block4, block5, coefX);
428     resultY = mix(block7, block8, coefX);
429     shadow += mix(resultX, resultY, coefY);
430     return shadow * 0.25;
431   }
432   float CCGetSpotLightShadowFactorHard (vec4 shadowPos, vec3 worldPos, float bias) {
433     vec4 clipPosNew = ApplyShadowDepthBias_Perspective(shadowPos, bias);
434     vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;
435     if (clipPos.x < 0.0 || clipPos.x > 1.0 ||
436         clipPos.y < 0.0 || clipPos.y > 1.0 ||
437         clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }
438     clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;
439     float shadow = 0.0;
440     float closestDepth = 0.0;
441     float depth = clipPos.z;
442     if (cc_shadowLPNNInfo.y > EPSILON) {
443       closestDepth = dot(texture(cc_spotLightingMap, clipPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0));
444     } else {
445       closestDepth = texture(cc_spotLightingMap, clipPos.xy).x;
446     }
447     shadow = step(depth, closestDepth);
448     return shadow;
449   }
450   float CCGetSpotLightShadowFactorSoft (vec4 shadowPos, vec3 worldPos, float bias) {
451     vec4 clipPosNew = ApplyShadowDepthBias_Perspective(shadowPos, bias);
452     vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;
453     if (clipPos.x < 0.0 || clipPos.x > 1.0 ||
454         clipPos.y < 0.0 || clipPos.y > 1.0 ||
455         clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }
456     clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;
457     float depth = 0.0;
458     if (cc_shadowNFLSInfo.z > EPSILON) {
459       depth = CCGetLinearDepth(worldPos);
460     } else {
461       depth = clipPos.z;
462     }
463     vec2 oneTap = 1.0 / cc_shadowWHPBInfo.xy;
464     vec2 clipPos_offset = clipPos.xy + oneTap;
465     float block0, block1, block2, block3;
466     if (cc_shadowLPNNInfo.y > EPSILON) {
467       block0 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));
468       block1 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));
469       block2 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));
470       block3 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));
471     } else {
472       block0 = step(depth, texture(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)).x);
473       block1 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos.y)).x);
474       block2 = step(depth, texture(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset.y)).x);
475       block3 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos_offset.y)).x);
476     }
477     float coefX   = mod(clipPos.x, oneTap.x) * cc_shadowWHPBInfo.x;
478     float resultX = mix(block0, block1, coefX);
479     float resultY = mix(block2, block3, coefX);
480     float coefY   = mod(clipPos.y, oneTap.y) * cc_shadowWHPBInfo.y;
481     return mix(resultX, resultY, coefY);
482   }
483   float CCGetSpotLightShadowFactorSoft2X (vec4 shadowPos, vec3 worldPos, float bias) {
484     vec4 clipPosNew = ApplyShadowDepthBias_Perspective(shadowPos, bias);
485     vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;
486     if (clipPos.x < 0.0 || clipPos.x > 1.0 ||
487         clipPos.y < 0.0 || clipPos.y > 1.0 ||
488         clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }
489     clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;
490     float depth = 0.0;
491     if (cc_shadowNFLSInfo.z > EPSILON) {
492       depth = CCGetLinearDepth(worldPos);
493     } else {
494       depth = clipPos.z;
495     }
496     vec2 mapSize = cc_shadowWHPBInfo.xy;
497     vec2 oneTap = 1.0 / mapSize;
498     float clipPos_offset_L = clipPos.x - oneTap.x;
499     float clipPos_offset_R = clipPos.x + oneTap.x;
500     float clipPos_offset_U = clipPos.y - oneTap.y;
501     float clipPos_offset_D = clipPos.y + oneTap.y;
502     float block0, block1, block2, block3, block4, block5, block6, block7, block8;
503     if (cc_shadowLPNNInfo.y > EPSILON) {
504       block0 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));
505       block1 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));
506       block2 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));
507       block3 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));
508       block4 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));
509       block5 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));
510       block6 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));
511       block7 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));
512       block8 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));
513     } else {
514       block0 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_U)).x);
515       block1 = step(depth, texture(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_U)).x);
516       block2 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_U)).x);
517       block3 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos.y)).x);
518       block4 = step(depth, texture(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)).x);
519       block5 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos.y)).x);
520       block6 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_D)).x);
521       block7 = step(depth, texture(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_D)).x);
522       block8 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_D)).x);
523     }
524     float coefX = mod(clipPos.x, oneTap.x) * mapSize.x;
525     float coefY = mod(clipPos.y, oneTap.y) * mapSize.y;
526     float shadow = 0.0;
527     float resultX = mix(block0, block1, coefX);
528     float resultY = mix(block3, block4, coefX);
529     shadow += mix(resultX , resultY, coefY);
530     resultX = mix(block1, block2, coefX);
531     resultY = mix(block4, block5, coefX);
532     shadow += mix(resultX , resultY, coefY);
533     resultX = mix(block3, block4, coefX);
534     resultY = mix(block6, block7, coefX);
535     shadow += mix(resultX, resultY, coefY);
536     resultX = mix(block4, block5, coefX);
537     resultY = mix(block7, block8, coefX);
538     shadow += mix(resultX, resultY, coefY);
539     return shadow * 0.25;
540   }
541 float CCSpotShadowFactorBase(vec4 shadowPos, vec3 worldPos, vec2 shadowBias)
542 {
543   float pcf = cc_shadowWHPBInfo.z;
544   if (pcf > 1.9) {
545     return CCGetSpotLightShadowFactorSoft2X(shadowPos, worldPos, shadowBias.x);
546   }else if (pcf > 0.9) {
547     return CCGetSpotLightShadowFactorSoft(shadowPos, worldPos, shadowBias.x);
548   }else {
549     return CCGetSpotLightShadowFactorHard(shadowPos, worldPos, shadowBias.x);
550   }
551 }
552 float CCShadowFactorBase(vec4 shadowPos, vec3 N, vec2 shadowBias)
553 {
554   float realtimeShadow = 1.0;
555   vec4 pos = ApplyShadowDepthBias_FaceNormal(shadowPos, N, shadowBias.y);
556   float pcf = cc_shadowWHPBInfo.z;
557   if (pcf > 1.9) {
558     realtimeShadow =  CCGetShadowFactorSoft2X(pos, shadowBias.x);
559   }else if (pcf > 0.9) {
560     realtimeShadow = CCGetShadowFactorSoft(pos, shadowBias.x);
561   }else {
562     realtimeShadow = CCGetShadowFactorHard(pos, shadowBias.x);
563   }
564   return mix(realtimeShadow, 1.0, cc_shadowNFLSInfo.w);
565 }
566 #endif
567 #if CC_USE_IBL
568   uniform samplerCube cc_environment;
569   vec4 fragTextureLod (sampler2D tex, vec2 coord, float lod) {
570       return textureLod(tex, coord, lod);
571   }
572   vec4 fragTextureLod (samplerCube tex, vec3 coord, float lod) {
573       return textureLod(tex, coord, lod);
574   }
575   vec3 unpackRGBE (vec4 rgbe) {
576     return rgbe.rgb * pow(1.1, rgbe.a * 255.0 - 128.0);
577   }
578   #if CC_USE_DIFFUSEMAP
579     uniform samplerCube cc_diffuseMap;
580   #endif
581 #endif
582 float GGXMobile (float roughness, float NoH, vec3 H, vec3 N) {
583   vec3 NxH = cross(N, H);
584   float OneMinusNoHSqr = dot(NxH, NxH);
585   float a = roughness * roughness;
586   float n = NoH * a;
587   float p = a / (OneMinusNoHSqr + n * n);
588   return p * p;
589 }
590 float CalcSpecular (float roughness, float NoH, vec3 H, vec3 N) {
591   return (roughness * 0.25 + 0.25) * GGXMobile(roughness, NoH, H, N);
592 }
593 vec3 BRDFApprox (vec3 specular, float roughness, float NoV) {
594   const vec4 c0 = vec4(-1.0, -0.0275, -0.572, 0.022);
595   const vec4 c1 = vec4(1.0, 0.0425, 1.04, -0.04);
596   vec4 r = roughness * c0 + c1;
597   float a004 = min(r.x * r.x, exp2(-9.28 * NoV)) * r.x + r.y;
598   vec2 AB = vec2(-1.04, 1.04) * a004 + r.zw;
599   AB.y *= clamp(50.0 * specular.g, 0.0, 1.0);
600   return specular * AB.x + AB.y;
601 }
602 #if USE_REFLECTION_DENOISE
603   vec3 GetEnvReflectionWithMipFiltering(vec3 R, float roughness, float mipCount, float denoiseIntensity) {
604     #if CC_USE_IBL
605     	float mip = roughness * mipCount;
606     	float delta = (dot(dFdx(R), dFdy(R))) * 1000.0;
607     	float mipBias = mix(0.0, 5.0, clamp(delta, 0.0, 1.0));
608     	vec4 biased = fragTextureLod(cc_environment, R, mip + mipBias);
609      	vec4 filtered = texture(cc_environment, R);
610       #if CC_USE_IBL == 2
611       	biased.rgb = unpackRGBE(biased);
612       	filtered.rgb = unpackRGBE(filtered);
613       #else
614       	biased.rgb = SRGBToLinear(biased.rgb);
615       	filtered.rgb = SRGBToLinear(filtered.rgb);
616       #endif
617       return mix(biased.rgb, filtered.rgb, denoiseIntensity);
618     #else
619       return vec3(0.0, 0.0, 0.0);
620     #endif
621   }
622 #endif
623 struct StandardSurface {
624   vec4 albedo;
625   #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES
626   vec3 position, position_fract_part;
627   #else
628   vec3 position;
629   #endif
630   vec3 normal;
631   vec3 emissive;
632   vec3 lightmap;
633   float lightmap_test;
634   float roughness;
635   float metallic;
636   float occlusion;
637   float specularIntensity;
638   #if CC_RECEIVE_SHADOW
639     vec2 shadowBias;
640   #endif
641 };
642 vec4 CCStandardShadingBase (StandardSurface s, vec4 shadowPos) {
643   vec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);
644   vec3 specular = mix(vec3(0.08 * s.specularIntensity), s.albedo.rgb, s.metallic);
645   vec3 position;
646   #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES
647   position = unpackHighpData(s.position, s.position_fract_part);
648   #else
649   position = s.position;
650   #endif
651   vec3 N = normalize(s.normal);
652   vec3 V = normalize(cc_cameraPos.xyz - position);
653   float NV = max(abs(dot(N, V)), 0.0);
654   specular = BRDFApprox(specular, s.roughness, NV);
655   vec3 L = normalize(-cc_mainLitDir.xyz);
656   vec3 H = normalize(L + V);
657   float NH = max(dot(N, H), 0.0);
658   float NL = max(dot(N, L), 0.0);
659   vec3 finalColor = NL * cc_mainLitColor.rgb * cc_mainLitColor.w;
660   vec3 diffuseContrib = diffuse / PI;
661   vec3 specularContrib = specular * CalcSpecular(s.roughness, NH, H, N);
662   vec3 dirlightContrib = (diffuseContrib + specularContrib);
663   float shadow = 1.0;
664   #if CC_RECEIVE_SHADOW
665     if (NL > 0.0 && cc_mainLitDir.w > 0.0) {
666       shadow = CCShadowFactorBase(shadowPos, N, s.shadowBias);
667     }
668   #endif
669   dirlightContrib *= shadow;
670   finalColor *= dirlightContrib;
671   #if CC_USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD
672     if (s.lightmap_test > EPSILON_LOWP) {
673       finalColor = diffuse * s.lightmap.rgb * shadow;
674     }
675   #endif
676   float fAmb = 0.5 - N.y * 0.5;
677   vec3 ambDiff = mix(cc_ambientSky.rgb, cc_ambientGround.rgb, fAmb);
678   #if CC_USE_IBL
679     #if CC_USE_DIFFUSEMAP
680       vec4 diffuseMap = texture(cc_diffuseMap, N);
681       #if CC_USE_DIFFUSEMAP == 2
682         ambDiff = unpackRGBE(diffuseMap);
683       #else
684         ambDiff = SRGBToLinear(diffuseMap.rgb);
685       #endif
686     #endif
687     vec3 R = normalize(reflect(-V, N));
688     #if USE_REFLECTION_DENOISE
689       vec3 env = GetEnvReflectionWithMipFiltering(R, s.roughness, cc_ambientGround.w, 0.6);
690     #else
691       vec4 envmap = fragTextureLod(cc_environment, R, s.roughness * cc_ambientGround.w);
692       #if CC_USE_IBL == 2
693         vec3 env = unpackRGBE(envmap);
694       #else
695         vec3 env = SRGBToLinear(envmap.rgb);
696       #endif
697     #endif
698     finalColor += env * cc_ambientSky.w * specular * s.occlusion;
699   #endif
700   finalColor += ambDiff.rgb * cc_ambientSky.w * diffuse * s.occlusion;
701   finalColor += s.emissive;
702   return vec4(finalColor, s.albedo.a);
703 }
704 vec3 ACESToneMap (vec3 color) {
705   color = min(color, vec3(8.0));
706   const float A = 2.51;
707   const float B = 0.03;
708   const float C = 2.43;
709   const float D = 0.59;
710   const float E = 0.14;
711   return (color * (A * color + B)) / (color * (C * color + D) + E);
712 }
713 vec4 CCFragOutput (vec4 color) {
714   #if CC_USE_HDR
715     color.rgb = ACESToneMap(color.rgb);
716   #endif
717   color.rgb = sqrt(color.rgb);
718   return color;
719 }
720 in highp vec4 v_shadowPos;
721 #if CC_RECEIVE_SHADOW
722 #endif
723 #if CC_USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD
724   in vec3 v_luv;
725   uniform sampler2D cc_lightingMap;
726 #endif
727 in vec3 v_position;
728 in vec2 v_uv;
729 #if HAS_SECOND_UV
730   in mediump vec2 v_uv1;
731 #endif
732 in mediump vec3 v_normal;
733 #if CC_RECEIVE_SHADOW
734   in mediump vec2 v_shadowBias;
735 #endif
736 #if USE_VERTEX_COLOR
737   in lowp vec4 v_color;
738 #endif
739 #if USE_ALBEDO_MAP
740   uniform sampler2D albedoMap;
741 #endif
742 #if USE_NORMAL_MAP
743   in mediump vec4 v_tangent;
744   uniform sampler2D normalMap;
745 #endif
746 #if USE_PBR_MAP
747   uniform sampler2D pbrMap;
748 #endif
749 #if USE_METALLIC_ROUGHNESS_MAP
750   uniform sampler2D metallicRoughnessMap;
751 #endif
752 #if USE_OCCLUSION_MAP
753   uniform sampler2D occlusionMap;
754 #endif
755 #if USE_EMISSIVE_MAP
756   uniform sampler2D emissiveMap;
757 #endif
758 #if USE_ALPHA_TEST
759 #endif
760 void surf (out StandardSurface s) {
761   vec4 baseColor = albedo;
762   #if USE_VERTEX_COLOR
763     baseColor.rgb *= SRGBToLinear(v_color.rgb);
764     baseColor.a *= v_color.a;
765   #endif
766   #if USE_ALBEDO_MAP
767     vec4 texColor = texture(albedoMap, ALBEDO_UV);
768     texColor.rgb = SRGBToLinear(texColor.rgb);
769     baseColor *= texColor;
770   #endif
771   s.albedo = baseColor;
772   s.albedo.rgb *= albedoScaleAndCutoff.xyz;
773   #if USE_ALPHA_TEST
774     if (s.albedo.ALPHA_TEST_CHANNEL < albedoScaleAndCutoff.w) discard;
775   #endif
776   #if CC_USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD
777     vec4 lightColor = texture(cc_lightingMap, v_luv.xy);
778     s.lightmap = lightColor.xyz * v_luv.z;
779     s.lightmap_test = v_luv.z;
780   #endif
781   s.normal = v_normal;
782   #if CC_RECEIVE_SHADOW
783     s.shadowBias = v_shadowBias;
784   #endif
785   #if USE_NORMAL_MAP
786     vec3 nmmp = texture(normalMap, NORMAL_UV).xyz - vec3(0.5);
787     vec3 bitangent = cross(v_normal, v_tangent.xyz) * v_tangent.w;
788     s.normal =
789       (nmmp.x * emissiveScaleParam.w) * normalize(v_tangent.xyz) +
790       (nmmp.y * emissiveScaleParam.w) * normalize(bitangent) +
791       nmmp.z * normalize(s.normal);
792   #endif
793   #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES
794   packHighpData(s.position, s.position_fract_part, v_position);
795   #else
796   s.position = v_position;
797   #endif
798   vec4 pbr = pbrParams;
799   #if USE_PBR_MAP
800     vec4 res = texture(pbrMap, PBR_UV);
801     pbr.x *= res.r;
802     pbr.y *= res.g;
803     pbr.z *= res.b;
804     pbr.w *= res.a;
805   #endif
806   #if USE_METALLIC_ROUGHNESS_MAP
807     vec4 metallicRoughness = texture(metallicRoughnessMap, PBR_UV);
808     pbr.z *= metallicRoughness.b;
809     pbr.y *= metallicRoughness.g;
810   #endif
811   #if USE_OCCLUSION_MAP
812     pbr.x *= texture(occlusionMap, PBR_UV).r;
813   #endif
814   s.occlusion = pbr.x;
815   s.roughness = pbr.y;
816   s.specularIntensity = 0.5;
817   s.metallic = pbr.z;
818   s.emissive = emissive.rgb * emissiveScaleParam.xyz;
819   #if USE_EMISSIVE_MAP
820     s.emissive *= SRGBToLinear(texture(emissiveMap, EMISSIVE_UV).rgb);
821   #endif
822 }
823 #if CC_FORWARD_ADD
824   #if CC_PIPELINE_TYPE == 0
825     #define LIGHTS_PER_PASS 1
826   #else
827     #define LIGHTS_PER_PASS 10
828   #endif
829   #if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 0
830   layout(std140) uniform CCForwardLight {
831     highp vec4 cc_lightPos[LIGHTS_PER_PASS];
832     vec4 cc_lightColor[LIGHTS_PER_PASS];
833     vec4 cc_lightSizeRangeAngle[LIGHTS_PER_PASS];
834     vec4 cc_lightDir[LIGHTS_PER_PASS];
835   };
836   #endif
837   float SmoothDistAtt (float distSqr, float invSqrAttRadius) {
838     float factor = distSqr * invSqrAttRadius;
839     float smoothFactor = clamp(1.0 - factor * factor, 0.0, 1.0);
840     return smoothFactor * smoothFactor;
841   }
842   float GetDistAtt (float distSqr, float invSqrAttRadius) {
843     float attenuation = 1.0 / max(distSqr, 0.01*0.01);
844     attenuation *= SmoothDistAtt(distSqr , invSqrAttRadius);
845     return attenuation;
846   }
847   float GetAngleAtt (vec3 L, vec3 litDir, float litAngleScale, float litAngleOffset) {
848     float cd = dot(litDir, L);
849     float attenuation = clamp(cd * litAngleScale + litAngleOffset, 0.0, 1.0);
850     return (attenuation * attenuation);
851   }
852   #if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 0
853   vec4 CCStandardShadingAdditive (StandardSurface s, vec4 shadowPos) {
854     vec3 position;
855     #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES
856     position = unpackHighpData(s.position, s.position_fract_part);
857     #else
858     position = s.position;
859     #endif
860     vec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);
861     vec3 specular = mix(vec3(0.04), s.albedo.rgb, s.metallic);
862     vec3 diffuseContrib = diffuse / PI;
863     vec3 N = normalize(s.normal);
864     vec3 V = normalize(cc_cameraPos.xyz - position);
865     float NV = max(abs(dot(N, V)), 0.0);
866     specular = BRDFApprox(specular, s.roughness, NV);
867     vec3 finalColor = vec3(0.0);
868     int numLights = CC_PIPELINE_TYPE == 0 ? LIGHTS_PER_PASS : int(cc_lightDir[0].w);
869     for (int i = 0; i < LIGHTS_PER_PASS; i++) {
870       if (i >= numLights) break;
871       vec3 SLU = cc_lightPos[i].xyz - position;
872       vec3 SL = normalize(SLU);
873       vec3 SH = normalize(SL + V);
874       float SNL = max(dot(N, SL), 0.0);
875       float SNH = max(dot(N, SH), 0.0);
876       float distSqr = dot(SLU, SLU);
877       float litRadius = cc_lightSizeRangeAngle[i].x;
878       float litRadiusSqr = litRadius * litRadius;
879       float illum = litRadiusSqr / max(litRadiusSqr, distSqr);
880       float attRadiusSqrInv = 1.0 / max(cc_lightSizeRangeAngle[i].y, 0.01);
881       attRadiusSqrInv *= attRadiusSqrInv;
882       float att = GetDistAtt(distSqr, attRadiusSqrInv);
883       vec3 lspec = specular * CalcSpecular(s.roughness, SNH, SH, N);
884       if (cc_lightPos[i].w > 0.0) {
885         float cosInner = max(dot(-cc_lightDir[i].xyz, SL), 0.01);
886         float cosOuter = cc_lightSizeRangeAngle[i].z;
887         float litAngleScale = 1.0 / max(0.001, cosInner - cosOuter);
888         float litAngleOffset = -cosOuter * litAngleScale;
889         att *= GetAngleAtt(SL, -cc_lightDir[i].xyz, litAngleScale, litAngleOffset);
890       }
891       vec3 lightColor = cc_lightColor[i].rgb;
892       float shadow = 1.0;
893       #if CC_RECEIVE_SHADOW
894         if (cc_lightPos[i].w > 0.0 && cc_lightSizeRangeAngle[i].w > 0.0) {
895           shadow = CCSpotShadowFactorBase(shadowPos, position, s.shadowBias);
896         }
897       #endif
898       lightColor *= shadow;
899       finalColor += SNL * lightColor * cc_lightColor[i].w * illum * att * (diffuseContrib + lspec);
900     }
901     return vec4(finalColor, 0.0);
902   }
903   #endif
904   #if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 1
905   layout(std430, binding = 4) readonly buffer b_ccLightsBuffer { vec4 b_ccLights[]; };
906   layout(std430, binding = 5) readonly buffer b_clusterLightIndicesBuffer { uint b_clusterLightIndices[]; };
907   layout(std430, binding = 6) readonly buffer b_clusterLightGridBuffer { uvec4 b_clusterLightGrid[]; };
908   struct CCLight
909   {
910     vec4 cc_lightPos;
911     vec4 cc_lightColor;
912     vec4 cc_lightSizeRangeAngle;
913     vec4 cc_lightDir;
914   };
915   struct Cluster
916   {
917     vec3 minBounds;
918     vec3 maxBounds;
919   };
920   struct LightGrid
921   {
922     uint offset;
923     uint ccLights;
924   };
925   CCLight getCCLight(uint i)
926   {
927     CCLight light;
928     light.cc_lightPos = b_ccLights[4u * i + 0u];
929     light.cc_lightColor = b_ccLights[4u * i + 1u];
930     light.cc_lightSizeRangeAngle = b_ccLights[4u * i + 2u];
931     light.cc_lightDir = b_ccLights[4u * i + 3u];
932     return light;
933   }
934   LightGrid getLightGrid(uint cluster)
935   {
936     uvec4 gridvec = b_clusterLightGrid[cluster];
937     LightGrid grid;
938     grid.offset = gridvec.x;
939     grid.ccLights = gridvec.y;
940     return grid;
941   }
942   uint getGridLightIndex(uint start, uint offset)
943   {
944     return b_clusterLightIndices[start + offset];
945   }
946   uint getClusterZIndex(vec4 worldPos)
947   {
948     float scale = float(24) / log(cc_nearFar.y / cc_nearFar.x);
949     float bias = -(float(24) * log(cc_nearFar.x) / log(cc_nearFar.y / cc_nearFar.x));
950     float eyeDepth = -(cc_matView * worldPos).z;
951     uint zIndex = uint(max(log(eyeDepth) * scale + bias, 0.0));
952     return zIndex;
953   }
954   uint getClusterIndex(vec4 fragCoord, vec4 worldPos)
955   {
956     uint zIndex = getClusterZIndex(worldPos);
957     float clusterSizeX = ceil(cc_viewPort.z / float(16));
958     float clusterSizeY = ceil(cc_viewPort.w / float(8));
959     uvec3 indices = uvec3(uvec2(fragCoord.xy / vec2(clusterSizeX, clusterSizeY)), zIndex);
960     uint cluster = (16u * 8u) * indices.z + 16u * indices.y + indices.x;
961     return cluster;
962   }
963   vec4 CCClusterShadingAdditive (StandardSurface s, vec4 shadowPos) {
964     vec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);
965     vec3 specular = mix(vec3(0.04), s.albedo.rgb, s.metallic);
966     vec3 diffuseContrib = diffuse / PI;
967     vec3 position;
968     #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES
969     position = unpackHighpData(s.position, s.position_fract_part);
970     #else
971     position = s.position;
972     #endif
973     vec3 N = normalize(s.normal);
974     vec3 V = normalize(cc_cameraPos.xyz - position);
975     float NV = max(abs(dot(N, V)), 0.001);
976     specular = BRDFApprox(specular, s.roughness, NV);
977     vec3 finalColor = vec3(0.0);
978     uint cluster = getClusterIndex(gl_FragCoord, vec4(position, 1.0));
979     LightGrid grid = getLightGrid(cluster);
980     uint numLights = grid.ccLights;
981     for (uint i = 0u; i < 100u; i++) {
982       if (i >= numLights) break;
983       uint lightIndex = getGridLightIndex(grid.offset, i);
984       CCLight light = getCCLight(lightIndex);
985       vec3 SLU = light.cc_lightPos.xyz - position;
986       vec3 SL = normalize(SLU);
987       vec3 SH = normalize(SL + V);
988       float SNL = max(dot(N, SL), 0.001);
989       float SNH = max(dot(N, SH), 0.0);
990       float distSqr = dot(SLU, SLU);
991       float litRadius = light.cc_lightSizeRangeAngle.x;
992       float litRadiusSqr = litRadius * litRadius;
993       float illum = PI * (litRadiusSqr / max(litRadiusSqr , distSqr));
994       float attRadiusSqrInv = 1.0 / max(light.cc_lightSizeRangeAngle.y, 0.01);
995       attRadiusSqrInv *= attRadiusSqrInv;
996       float att = GetDistAtt(distSqr, attRadiusSqrInv);
997       vec3 lspec = specular * CalcSpecular(s.roughness, SNH, SH, N);
998       if (light.cc_lightPos.w > 0.0) {
999         float cosInner = max(dot(-light.cc_lightDir.xyz, SL), 0.01);
1000         float cosOuter = light.cc_lightSizeRangeAngle.z;
1001         float litAngleScale = 1.0 / max(0.001, cosInner - cosOuter);
1002         float litAngleOffset = -cosOuter * litAngleScale;
1003         att *= GetAngleAtt(SL, -light.cc_lightDir.xyz, litAngleScale, litAngleOffset);
1004       }
1005       vec3 lightColor = light.cc_lightColor.rgb;
1006       float shadow = 1.0;
1007       #if CC_RECEIVE_SHADOW
1008         if (light.cc_lightPos.w > 0.0) {
1009           shadow = CCSpotShadowFactorBase(shadowPos, position, s.shadowBias);
1010         }
1011       #endif
1012       lightColor *= shadow;
1013       finalColor += SNL * lightColor * light.cc_lightColor.w * illum * att * (diffuseContrib + lspec);
1014     }
1015     return vec4(finalColor, 0.0);
1016   }
1017   #endif
1018   layout(location = 0) out vec4 fragColorX;
1019   void main () {
1020     StandardSurface s; surf(s);
1021     #if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 1
1022     vec4 color = CCClusterShadingAdditive(s, v_shadowPos);
1023     #else
1024     vec4 color = CCStandardShadingAdditive(s, v_shadowPos);
1025     #endif
1026     fragColorX = CCFragOutput(color);
1027   }
1028 #elif (CC_PIPELINE_TYPE == 0 || CC_FORCE_FORWARD_SHADING)
1029   layout(location = 0) out vec4 fragColorX;
1030   void main () {
1031     StandardSurface s; surf(s);
1032     vec4 color = CCStandardShadingBase(s, v_shadowPos);
1033     CC_APPLY_FOG(color, s.position.xyz);
1034     fragColorX = CCFragOutput(color);
1035   }
1036 #elif CC_PIPELINE_TYPE == 1
1037   vec2 signNotZero(vec2 v) {
1038     return vec2((v.x >= 0.0) ? +1.0 : -1.0, (v.y >= 0.0) ? +1.0 : -1.0);
1039   }
1040   vec2 float32x3_to_oct(in vec3 v) {
1041     vec2 p = v.xy * (1.0 / (abs(v.x) + abs(v.y) + abs(v.z)));
1042     return (v.z <= 0.0) ? ((1.0 - abs(p.yx)) * signNotZero(p)) : p;
1043   }
1044   layout(location = 0) out vec4 fragColor0;
1045   layout(location = 1) out vec4 fragColor1;
1046   layout(location = 2) out vec4 fragColor2;
1047   void main () {
1048     StandardSurface s; surf(s);
1049     fragColor0 = s.albedo;
1050     fragColor1 = vec4(float32x3_to_oct(s.normal), s.roughness, s.metallic);
1051     fragColor2 = vec4(s.emissive, s.occlusion);
1052   }
1053 #endif
2022-07-08 13:36:49-error: [Scene] ERROR: 0:626: 'CC_PLATFORM_ANDROID_AND_WEBGL' : unexpected token after conditional expression
ERROR: 0:626: 'CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES' : unexpected token after conditional expression
ERROR: 0:647: 'CC_PLATFORM_ANDROID_AND_WEBGL' : unexpected token after conditional expression
ERROR: 0:647: 'CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES' : unexpected token after conditional expression
ERROR: 0:794: 'CC_PLATFORM_ANDROID_AND_WEBGL' : unexpected token after conditional expression
ERROR: 0:794: 'CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES' : unexpected token after conditional expression
WARNING: 0:1054: '' : unexpected end of file found in directive
 
2022-07-08 13:36:49-error: [Scene] FragmentShader in 'builtin-standard|standard-vs|standard-fs|CC_USE_FOG4|CC_FORWARD_ADD1|CC_USE_HDR1' compilation failed.
2022-07-08 13:36:49-error: [Scene] Shader source dump: 
1 #define CC_DEVICE_SUPPORT_FLOAT_TEXTURE 1
2 #define CC_ENABLE_CLUSTERED_LIGHT_CULLING 0
3 #define CC_DEVICE_MAX_VERTEX_UNIFORM_VECTORS 4095
4 #define CC_DEVICE_MAX_FRAGMENT_UNIFORM_VECTORS 1024
5 #define CC_DEVICE_CAN_BENEFIT_FROM_INPUT_ATTACHMENT 0
6 #define CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS 223
7 #define CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS 75
8 #define USE_INSTANCING 0
9 #define USE_BATCHING 0
10 #define CC_USE_SKINNING 0
11 #define CC_USE_BAKED_ANIMATION 0
12 #define CC_USE_LIGHTMAP 0
13 #define CC_RECEIVE_SHADOW 0
14 #define CC_USE_MORPH 0
15 #define CC_MORPH_TARGET_COUNT 2
16 #define CC_MORPH_PRECOMPUTED 0
17 #define CC_MORPH_TARGET_HAS_POSITION 0
18 #define CC_MORPH_TARGET_HAS_NORMAL 0
19 #define CC_MORPH_TARGET_HAS_TANGENT 0
20 #define CC_USE_FOG 4
21 #define CC_USE_ACCURATE_FOG 0
22 #define USE_VERTEX_COLOR 0
23 #define HAS_SECOND_UV 0
24 #define USE_NORMAL_MAP 0
25 #define CC_FORWARD_ADD 1
26 #define USE_TWOSIDE 0
27 #define SAMPLE_FROM_RT 0
28 #define CC_USE_IBL 0
29 #define CC_USE_DIFFUSEMAP 0
30 #define USE_REFLECTION_DENOISE 0
31 #define CC_USE_HDR 1
32 #define USE_ALBEDO_MAP 0
33 #define ALBEDO_UV v_uv
34 #define NORMAL_UV v_uv
35 #define PBR_UV v_uv
36 #define USE_PBR_MAP 0
37 #define USE_METALLIC_ROUGHNESS_MAP 0
38 #define USE_OCCLUSION_MAP 0
39 #define USE_EMISSIVE_MAP 0
40 #define EMISSIVE_UV v_uv
41 #define USE_ALPHA_TEST 0
42 #define ALPHA_TEST_CHANNEL a
43 #define CC_PIPELINE_TYPE 0
44 #define CC_FORCE_FORWARD_SHADING 0
45 
46 precision highp float;
47 layout(std140) uniform CCGlobal {
48   highp   vec4 cc_time;
49   mediump vec4 cc_screenSize;
50   mediump vec4 cc_nativeSize;
51 };
52 layout(std140) uniform CCCamera {
53   highp   mat4 cc_matView;
54   highp   mat4 cc_matViewInv;
55   highp   mat4 cc_matProj;
56   highp   mat4 cc_matProjInv;
57   highp   mat4 cc_matViewProj;
58   highp   mat4 cc_matViewProjInv;
59   highp   vec4 cc_cameraPos;
60   mediump vec4 cc_screenScale;
61   mediump vec4 cc_exposure;
62   mediump vec4 cc_mainLitDir;
63   mediump vec4 cc_mainLitColor;
64   mediump vec4 cc_ambientSky;
65   mediump vec4 cc_ambientGround;
66   mediump vec4 cc_fogColor;
67   mediump vec4 cc_fogBase;
68   mediump vec4 cc_fogAdd;
69   mediump vec4 cc_nearFar;
70   mediump vec4 cc_viewPort;
71 };
72 layout(std140) uniform Constants {
73   vec4 tilingOffset;
74   vec4 albedo;
75   vec4 albedoScaleAndCutoff;
76   vec4 pbrParams;
77   vec4 emissive;
78   vec4 emissiveScaleParam;
79 };
80 float LinearFog(vec4 pos) {
81   vec4 wPos = pos;
82   float cam_dis = distance(cc_cameraPos, wPos);
83   float fogStart = cc_fogBase.x;
84   float fogEnd = cc_fogBase.y;
85   return clamp((fogEnd - cam_dis) / (fogEnd - fogStart), 0., 1.);
86 }
87 float ExpFog(vec4 pos) {
88   vec4 wPos = pos;
89   float fogAtten = cc_fogAdd.z;
90   float fogStart = cc_fogBase.x;
91   float fogDensity = cc_fogBase.z;
92   float cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;
93   float f = exp(-cam_dis * fogDensity);
94   return f;
95 }
96 float ExpSquaredFog(vec4 pos) {
97   vec4 wPos = pos;
98   float fogAtten = cc_fogAdd.z;
99   float fogStart = cc_fogBase.x;
100   float fogDensity = cc_fogBase.z;
101   float cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;
102   float f = exp(-cam_dis * cam_dis * fogDensity * fogDensity);
103   return f;
104 }
105 float LayeredFog(vec4 pos) {
106   vec4 wPos = pos;
107   float fogAtten = cc_fogAdd.z;
108   float _FogTop = cc_fogAdd.x;
109   float _FogRange = cc_fogAdd.y;
110   vec3 camWorldProj = cc_cameraPos.xyz;
111   camWorldProj.y = 0.;
112   vec3 worldPosProj = wPos.xyz;
113   worldPosProj.y = 0.;
114   float fDeltaD = distance(worldPosProj, camWorldProj) / fogAtten * 2.0;
115   float fDeltaY, fDensityIntegral;
116   if (cc_cameraPos.y > _FogTop) {
117     if (wPos.y < _FogTop) {
118       fDeltaY = (_FogTop - wPos.y) / _FogRange * 2.0;
119       fDensityIntegral = fDeltaY * fDeltaY * 0.5;
120     } else {
121       fDeltaY = 0.;
122       fDensityIntegral = 0.;
123     }
124   } else {
125     if (wPos.y < _FogTop) {
126       float fDeltaA = (_FogTop - cc_cameraPos.y) / _FogRange * 2.;
127       float fDeltaB = (_FogTop - wPos.y) / _FogRange * 2.;
128       fDeltaY = abs(fDeltaA - fDeltaB);
129       fDensityIntegral = abs((fDeltaA * fDeltaA * 0.5) - (fDeltaB * fDeltaB * 0.5));
130     } else {
131       fDeltaY = abs(_FogTop - cc_cameraPos.y) / _FogRange * 2.;
132       fDensityIntegral = abs(fDeltaY * fDeltaY * 0.5);
133     }
134   }
135   float fDensity;
136   if (fDeltaY != 0.) {
137     fDensity = (sqrt(1.0 + ((fDeltaD / fDeltaY) * (fDeltaD / fDeltaY)))) * fDensityIntegral;
138   } else {
139     fDensity = 0.;
140   }
141   float f = exp(-fDensity);
142   return f;
143 }
144 void CC_TRANSFER_FOG_BASE(vec4 pos, out float factor)
145 {
146   #if CC_USE_FOG == 0
147 	factor = LinearFog(pos);
148   #elif CC_USE_FOG == 1
149     factor = ExpFog(pos);
150   #elif CC_USE_FOG == 2
151     factor = ExpSquaredFog(pos);
152   #elif CC_USE_FOG == 3
153     factor = LayeredFog(pos);
154   #else
155     factor = 1.0;
156   #endif
157 }
158 void CC_APPLY_FOG_BASE(inout vec4 color, float factor) {
159   color = vec4(mix(cc_fogColor.rgb, color.rgb, factor), color.a);
160 }
161 #if !CC_USE_ACCURATE_FOG
162 in float v_fog_factor;
163 #endif
164 void CC_APPLY_FOG(inout vec4 color) {
165 #if !CC_USE_ACCURATE_FOG
166     CC_APPLY_FOG_BASE(color, v_fog_factor);
167 #endif
168 }
169 void CC_APPLY_FOG(inout vec4 color, vec3 worldPos) {
170 #if CC_USE_ACCURATE_FOG
171     float factor;
172     CC_TRANSFER_FOG_BASE(vec4(worldPos, 1.0), factor);
173 #else
174     float factor = v_fog_factor;
175 #endif
176     CC_APPLY_FOG_BASE(color, factor);
177 }
178 #define QUATER_PI         0.78539816340
179 #define HALF_PI           1.57079632679
180 #define PI                3.14159265359
181 #define PI2               6.28318530718
182 #define PI4               12.5663706144
183 #define INV_QUATER_PI     1.27323954474
184 #define INV_HALF_PI       0.63661977237
185 #define INV_PI            0.31830988618
186 #define INV_PI2           0.15915494309
187 #define INV_PI4           0.07957747155
188 #define EPSILON           1e-6
189 #define EPSILON_LOWP      1e-4
190 #define LOG2              1.442695
191 #define EXP_VALUE         2.71828183f
192 #define FP_MAX            65504.0
193 #define FP_SCALE          0.0009765625
194 #define FP_SCALE_INV      1024.0
195 #define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)
196 vec3 SRGBToLinear (vec3 gamma) {
197   return gamma * gamma;
198 }
199 layout(std140) uniform CCShadow {
200   highp mat4 cc_matLightPlaneProj;
201   highp mat4 cc_matLightView;
202   highp mat4 cc_matLightViewProj;
203   highp vec4 cc_shadowInvProjDepthInfo;
204   highp vec4 cc_shadowProjDepthInfo;
205   highp vec4 cc_shadowProjInfo;
206   mediump vec4 cc_shadowNFLSInfo;
207   mediump vec4 cc_shadowWHPBInfo;
208   mediump vec4 cc_shadowLPNNInfo;
209   lowp vec4 cc_shadowColor;
210   mediump vec4 cc_planarNDInfo;
211 };
212 highp float unpackHighpData (float mainPart, float modPart) {
213   highp float data = mainPart;
214   return data + modPart;
215 }
216 void packHighpData (out float mainPart, out float modPart, highp float data) {
217   mainPart = fract(data);
218   modPart = data - mainPart;
219 }
220 highp float unpackHighpData (float mainPart, float modPart, const float modValue) {
221   highp float data = mainPart * modValue;
222   return data + modPart * modValue;
223 }
224 void packHighpData (out float mainPart, out float modPart, highp float data, const float modValue) {
225   highp float divide = data / modValue;
226   mainPart = floor(divide);
227   modPart = (data - mainPart * modValue) / modValue;
228 }
229 highp vec2 unpackHighpData (vec2 mainPart, vec2 modPart) {
230   highp vec2 data = mainPart;
231   return data + modPart;
232 }
233 void packHighpData (out vec2 mainPart, out vec2 modPart, highp vec2 data) {
234   mainPart = fract(data);
235   modPart = data - mainPart;
236 }
237 highp vec2 unpackHighpData (vec2 mainPart, vec2 modPart, const float modValue) {
238   highp vec2 data = mainPart * modValue;
239   return data + modPart * modValue;
240 }
241 void packHighpData (out vec2 mainPart, out vec2 modPart, highp vec2 data, const float modValue) {
242   highp vec2 divide = data / modValue;
243   mainPart = floor(divide);
244   modPart = (data - mainPart * modValue) / modValue;
245 }
246 highp vec3 unpackHighpData (vec3 mainPart, vec3 modPart) {
247   highp vec3 data = mainPart;
248   return data + modPart;
249 }
250 void packHighpData (out vec3 mainPart, out vec3 modPart, highp vec3 data) {
251   mainPart = fract(data);
252   modPart = data - mainPart;
253 }
254 highp vec3 unpackHighpData (vec3 mainPart, vec3 modPart, const float modValue) {
255   highp vec3 data = mainPart * modValue;
256   return data + modPart * modValue;
257 }
258 void packHighpData (out vec3 mainPart, out vec3 modPart, highp vec3 data, const float modValue) {
259   highp vec3 divide = data / modValue;
260   mainPart = floor(divide);
261   modPart = (data - mainPart * modValue) / modValue;
262 }
263 highp vec4 unpackHighpData (vec4 mainPart, vec4 modPart) {
264   highp vec4 data = mainPart;
265   return data + modPart;
266 }
267 void packHighpData (out vec4 mainPart, out vec4 modPart, highp vec4 data) {
268   mainPart = fract(data);
269   modPart = data - mainPart;
270 }
271 highp vec4 unpackHighpData (vec4 mainPart, vec4 modPart, const float modValue) {
272   highp vec4 data = mainPart * modValue;
273   return data + modPart * modValue;
274 }
275 void packHighpData (out vec4 mainPart, out vec4 modPart, highp vec4 data, const float modValue) {
276   highp vec4 divide = data / modValue;
277   mainPart = floor(divide);
278   modPart = (data - mainPart * modValue) / modValue;
279 }
280 layout(std140) uniform CCLocal {
281   highp mat4 cc_matWorld;
282   highp mat4 cc_matWorldIT;
283   highp vec4 cc_lightingMapUVParam;
284   highp vec4 cc_localShadowBias;
285 };
286 float CCGetLinearDepthFromViewSpace(vec3 viewPos) {
287   float dist = length(viewPos);
288   return (dist - cc_shadowNFLSInfo.x) / (cc_shadowNFLSInfo.y - cc_shadowNFLSInfo.x);
289 }
290 float CCGetLinearDepth(vec3 worldPos) {
291   vec4 viewStartPos = cc_matLightView * vec4(worldPos.xyz, 1.0);
292   return CCGetLinearDepthFromViewSpace(viewStartPos.xyz);
293 }
294 #if CC_RECEIVE_SHADOW
295   uniform highp sampler2D cc_shadowMap;
296   uniform highp sampler2D cc_spotLightingMap;
297   vec4 ApplyShadowDepthBias_FaceNormal(vec4 shadowPos, vec3 worldNormal, float normalBias)
298   {
299     vec4 newShadowPos = shadowPos;
300     if(normalBias > EPSILON_LOWP)
301     {
302       vec4 viewNormal = cc_matLightView * vec4(worldNormal, 0.0);
303       if(viewNormal.z < 0.1)
304         newShadowPos.xy += viewNormal.xy * cc_shadowProjInfo.xy * normalBias * clamp(viewNormal.z, 0.001, 0.1);
305     }
306     return newShadowPos;
307   }
308   vec4 ApplyShadowDepthBias_Perspective(vec4 shadowPos, float viewspaceDepthBias)
309   {
310     vec3 viewSpacePos;
311     viewSpacePos.xy = shadowPos.xy * cc_shadowProjInfo.zw;
312     viewSpacePos.z = shadowPos.z * cc_shadowInvProjDepthInfo.x + shadowPos.w * cc_shadowInvProjDepthInfo.y;
313     viewSpacePos.xyz += cc_shadowProjDepthInfo.z * normalize(viewSpacePos.xyz) * viewspaceDepthBias;
314     vec4 clipSpacePos;
315     clipSpacePos.xy = viewSpacePos.xy * cc_shadowProjInfo.xy;
316     clipSpacePos.zw = viewSpacePos.z * cc_shadowProjDepthInfo.xz + vec2(cc_shadowProjDepthInfo.y, 0.0);
317     if (cc_shadowNFLSInfo.z > EPSILON) {
318       clipSpacePos.z = CCGetLinearDepthFromViewSpace(viewSpacePos.xyz);
319       clipSpacePos.z = (clipSpacePos.z * 2.0 - 1.0) * clipSpacePos.w;
320     }
321     return clipSpacePos;
322   }
323   vec4 ApplyShadowDepthBias_Orthographic(vec4 shadowPos, float viewspaceDepthBias)
324   {
325     float coeffA = cc_shadowProjDepthInfo.x;
326     float coeffB = cc_shadowProjDepthInfo.y;
327     float viewSpacePos_z = (shadowPos.z - coeffB) / coeffA;
328     viewSpacePos_z += viewspaceDepthBias;
329     vec4 result = shadowPos;
330     result.z = viewSpacePos_z * coeffA + coeffB;
331     return result;
332   }
333   float CCGetShadowFactorHard (vec4 shadowPos, float bias) {
334     vec4 clipPosNew = ApplyShadowDepthBias_Orthographic(shadowPos, bias);
335     vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;
336     if (clipPos.x < 0.0 || clipPos.x > 1.0 ||
337         clipPos.y < 0.0 || clipPos.y > 1.0 ||
338         clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }
339     clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;
340     float shadow = 0.0;
341     float closestDepth = 0.0;
342     if (cc_shadowLPNNInfo.y > EPSILON) {
343       closestDepth = dot(texture(cc_shadowMap, clipPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0));
344     } else {
345       closestDepth = texture(cc_shadowMap, clipPos.xy).x;
346     }
347     shadow = step(clipPos.z, closestDepth);
348     return shadow;
349   }
350   float CCGetShadowFactorSoft (vec4 shadowPos, float bias) {
351     vec4 clipPosNew = ApplyShadowDepthBias_Orthographic(shadowPos, bias);
352     vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;
353     if (clipPos.x < 0.0 || clipPos.x > 1.0 ||
354         clipPos.y < 0.0 || clipPos.y > 1.0 ||
355         clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }
356     clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;
357     float offsetDepth = clipPos.z;
358     vec2 mapSize = cc_shadowWHPBInfo.xy;
359     vec2 oneTap = 1.0 / mapSize;
360     vec2 clipPos_offset = clipPos.xy + oneTap;
361     float block0, block1, block2, block3;
362     if (cc_shadowLPNNInfo.y > EPSILON) {
363       block0 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));
364       block1 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));
365       block2 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));
366       block3 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));
367     } else {
368       block0 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos.x, clipPos.y)).x);
369       block1 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset.x, clipPos.y)).x);
370       block2 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset.y)).x);
371       block3 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset.x, clipPos_offset.y)).x);
372     }
373     float coefX   = mod(clipPos.x, oneTap.x) * mapSize.x;
374     float resultX = mix(block0, block1, coefX);
375     float resultY = mix(block2, block3, coefX);
376     float coefY   = mod(clipPos.y, oneTap.y) * mapSize.y;
377     return mix(resultX, resultY, coefY);
378   }
379   float CCGetShadowFactorSoft2X (vec4 shadowPos, float bias) {
380     vec4 clipPosNew = ApplyShadowDepthBias_Orthographic(shadowPos, bias);
381     vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;
382     if (clipPos.x < 0.0 || clipPos.x > 1.0 ||
383         clipPos.y < 0.0 || clipPos.y > 1.0 ||
384         clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }
385     clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;
386     float offsetDepth = clipPos.z;
387     vec2 mapSize = cc_shadowWHPBInfo.xy;
388     vec2 oneTap = 1.0 / mapSize;
389     float clipPos_offset_L = clipPos.x - oneTap.x;
390     float clipPos_offset_R = clipPos.x + oneTap.x;
391     float clipPos_offset_U = clipPos.y - oneTap.y;
392     float clipPos_offset_D = clipPos.y + oneTap.y;
393     float block0, block1, block2, block3, block4, block5, block6, block7, block8;
394     if (cc_shadowLPNNInfo.y > EPSILON) {
395       block0 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));
396       block1 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));
397       block2 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));
398       block3 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));
399       block4 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));
400       block5 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));
401       block6 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));
402       block7 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));
403       block8 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));
404     } else {
405       block0 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_U)).x);
406       block1 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset_U)).x);
407       block2 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_U)).x);
408       block3 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos.y)).x);
409       block4 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos.x, clipPos.y)).x);
410       block5 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos.y)).x);
411       block6 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_D)).x);
412       block7 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset_D)).x);
413       block8 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_D)).x);
414     }
415     float coefX = mod(clipPos.x, oneTap.x) * mapSize.x;
416     float coefY = mod(clipPos.y, oneTap.y) * mapSize.y;
417     float shadow = 0.0;
418     float resultX = mix(block0, block1, coefX);
419     float resultY = mix(block3, block4, coefX);
420     shadow += mix(resultX , resultY, coefY);
421     resultX = mix(block1, block2, coefX);
422     resultY = mix(block4, block5, coefX);
423     shadow += mix(resultX , resultY, coefY);
424     resultX = mix(block3, block4, coefX);
425     resultY = mix(block6, block7, coefX);
426     shadow += mix(resultX, resultY, coefY);
427     resultX = mix(block4, block5, coefX);
428     resultY = mix(block7, block8, coefX);
429     shadow += mix(resultX, resultY, coefY);
430     return shadow * 0.25;
431   }
432   float CCGetSpotLightShadowFactorHard (vec4 shadowPos, vec3 worldPos, float bias) {
433     vec4 clipPosNew = ApplyShadowDepthBias_Perspective(shadowPos, bias);
434     vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;
435     if (clipPos.x < 0.0 || clipPos.x > 1.0 ||
436         clipPos.y < 0.0 || clipPos.y > 1.0 ||
437         clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }
438     clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;
439     float shadow = 0.0;
440     float closestDepth = 0.0;
441     float depth = clipPos.z;
442     if (cc_shadowLPNNInfo.y > EPSILON) {
443       closestDepth = dot(texture(cc_spotLightingMap, clipPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0));
444     } else {
445       closestDepth = texture(cc_spotLightingMap, clipPos.xy).x;
446     }
447     shadow = step(depth, closestDepth);
448     return shadow;
449   }
450   float CCGetSpotLightShadowFactorSoft (vec4 shadowPos, vec3 worldPos, float bias) {
451     vec4 clipPosNew = ApplyShadowDepthBias_Perspective(shadowPos, bias);
452     vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;
453     if (clipPos.x < 0.0 || clipPos.x > 1.0 ||
454         clipPos.y < 0.0 || clipPos.y > 1.0 ||
455         clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }
456     clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;
457     float depth = 0.0;
458     if (cc_shadowNFLSInfo.z > EPSILON) {
459       depth = CCGetLinearDepth(worldPos);
460     } else {
461       depth = clipPos.z;
462     }
463     vec2 oneTap = 1.0 / cc_shadowWHPBInfo.xy;
464     vec2 clipPos_offset = clipPos.xy + oneTap;
465     float block0, block1, block2, block3;
466     if (cc_shadowLPNNInfo.y > EPSILON) {
467       block0 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));
468       block1 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));
469       block2 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));
470       block3 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));
471     } else {
472       block0 = step(depth, texture(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)).x);
473       block1 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos.y)).x);
474       block2 = step(depth, texture(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset.y)).x);
475       block3 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos_offset.y)).x);
476     }
477     float coefX   = mod(clipPos.x, oneTap.x) * cc_shadowWHPBInfo.x;
478     float resultX = mix(block0, block1, coefX);
479     float resultY = mix(block2, block3, coefX);
480     float coefY   = mod(clipPos.y, oneTap.y) * cc_shadowWHPBInfo.y;
481     return mix(resultX, resultY, coefY);
482   }
483   float CCGetSpotLightShadowFactorSoft2X (vec4 shadowPos, vec3 worldPos, float bias) {
484     vec4 clipPosNew = ApplyShadowDepthBias_Perspective(shadowPos, bias);
485     vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;
486     if (clipPos.x < 0.0 || clipPos.x > 1.0 ||
487         clipPos.y < 0.0 || clipPos.y > 1.0 ||
488         clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }
489     clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;
490     float depth = 0.0;
491     if (cc_shadowNFLSInfo.z > EPSILON) {
492       depth = CCGetLinearDepth(worldPos);
493     } else {
494       depth = clipPos.z;
495     }
496     vec2 mapSize = cc_shadowWHPBInfo.xy;
497     vec2 oneTap = 1.0 / mapSize;
498     float clipPos_offset_L = clipPos.x - oneTap.x;
499     float clipPos_offset_R = clipPos.x + oneTap.x;
500     float clipPos_offset_U = clipPos.y - oneTap.y;
501     float clipPos_offset_D = clipPos.y + oneTap.y;
502     float block0, block1, block2, block3, block4, block5, block6, block7, block8;
503     if (cc_shadowLPNNInfo.y > EPSILON) {
504       block0 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));
505       block1 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));
506       block2 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));
507       block3 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));
508       block4 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));
509       block5 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));
510       block6 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));
511       block7 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));
512       block8 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));
513     } else {
514       block0 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_U)).x);
515       block1 = step(depth, texture(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_U)).x);
516       block2 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_U)).x);
517       block3 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos.y)).x);
518       block4 = step(depth, texture(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)).x);
519       block5 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos.y)).x);
520       block6 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_D)).x);
521       block7 = step(depth, texture(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_D)).x);
522       block8 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_D)).x);
523     }
524     float coefX = mod(clipPos.x, oneTap.x) * mapSize.x;
525     float coefY = mod(clipPos.y, oneTap.y) * mapSize.y;
526     float shadow = 0.0;
527     float resultX = mix(block0, block1, coefX);
528     float resultY = mix(block3, block4, coefX);
529     shadow += mix(resultX , resultY, coefY);
530     resultX = mix(block1, block2, coefX);
531     resultY = mix(block4, block5, coefX);
532     shadow += mix(resultX , resultY, coefY);
533     resultX = mix(block3, block4, coefX);
534     resultY = mix(block6, block7, coefX);
535     shadow += mix(resultX, resultY, coefY);
536     resultX = mix(block4, block5, coefX);
537     resultY = mix(block7, block8, coefX);
538     shadow += mix(resultX, resultY, coefY);
539     return shadow * 0.25;
540   }
541 float CCSpotShadowFactorBase(vec4 shadowPos, vec3 worldPos, vec2 shadowBias)
542 {
543   float pcf = cc_shadowWHPBInfo.z;
544   if (pcf > 1.9) {
545     return CCGetSpotLightShadowFactorSoft2X(shadowPos, worldPos, shadowBias.x);
546   }else if (pcf > 0.9) {
547     return CCGetSpotLightShadowFactorSoft(shadowPos, worldPos, shadowBias.x);
548   }else {
549     return CCGetSpotLightShadowFactorHard(shadowPos, worldPos, shadowBias.x);
550   }
551 }
552 float CCShadowFactorBase(vec4 shadowPos, vec3 N, vec2 shadowBias)
553 {
554   float realtimeShadow = 1.0;
555   vec4 pos = ApplyShadowDepthBias_FaceNormal(shadowPos, N, shadowBias.y);
556   float pcf = cc_shadowWHPBInfo.z;
557   if (pcf > 1.9) {
558     realtimeShadow =  CCGetShadowFactorSoft2X(pos, shadowBias.x);
559   }else if (pcf > 0.9) {
560     realtimeShadow = CCGetShadowFactorSoft(pos, shadowBias.x);
561   }else {
562     realtimeShadow = CCGetShadowFactorHard(pos, shadowBias.x);
563   }
564   return mix(realtimeShadow, 1.0, cc_shadowNFLSInfo.w);
565 }
566 #endif
567 #if CC_USE_IBL
568   uniform samplerCube cc_environment;
569   vec4 fragTextureLod (sampler2D tex, vec2 coord, float lod) {
570       return textureLod(tex, coord, lod);
571   }
572   vec4 fragTextureLod (samplerCube tex, vec3 coord, float lod) {
573       return textureLod(tex, coord, lod);
574   }
575   vec3 unpackRGBE (vec4 rgbe) {
576     return rgbe.rgb * pow(1.1, rgbe.a * 255.0 - 128.0);
577   }
578   #if CC_USE_DIFFUSEMAP
579     uniform samplerCube cc_diffuseMap;
580   #endif
581 #endif
582 float GGXMobile (float roughness, float NoH, vec3 H, vec3 N) {
583   vec3 NxH = cross(N, H);
584   float OneMinusNoHSqr = dot(NxH, NxH);
585   float a = roughness * roughness;
586   float n = NoH * a;
587   float p = a / (OneMinusNoHSqr + n * n);
588   return p * p;
589 }
590 float CalcSpecular (float roughness, float NoH, vec3 H, vec3 N) {
591   return (roughness * 0.25 + 0.25) * GGXMobile(roughness, NoH, H, N);
592 }
593 vec3 BRDFApprox (vec3 specular, float roughness, float NoV) {
594   const vec4 c0 = vec4(-1.0, -0.0275, -0.572, 0.022);
595   const vec4 c1 = vec4(1.0, 0.0425, 1.04, -0.04);
596   vec4 r = roughness * c0 + c1;
597   float a004 = min(r.x * r.x, exp2(-9.28 * NoV)) * r.x + r.y;
598   vec2 AB = vec2(-1.04, 1.04) * a004 + r.zw;
599   AB.y *= clamp(50.0 * specular.g, 0.0, 1.0);
600   return specular * AB.x + AB.y;
601 }
602 #if USE_REFLECTION_DENOISE
603   vec3 GetEnvReflectionWithMipFiltering(vec3 R, float roughness, float mipCount, float denoiseIntensity) {
604     #if CC_USE_IBL
605     	float mip = roughness * mipCount;
606     	float delta = (dot(dFdx(R), dFdy(R))) * 1000.0;
607     	float mipBias = mix(0.0, 5.0, clamp(delta, 0.0, 1.0));
608     	vec4 biased = fragTextureLod(cc_environment, R, mip + mipBias);
609      	vec4 filtered = texture(cc_environment, R);
610       #if CC_USE_IBL == 2
611       	biased.rgb = unpackRGBE(biased);
612       	filtered.rgb = unpackRGBE(filtered);
613       #else
614       	biased.rgb = SRGBToLinear(biased.rgb);
615       	filtered.rgb = SRGBToLinear(filtered.rgb);
616       #endif
617       return mix(biased.rgb, filtered.rgb, denoiseIntensity);
618     #else
619       return vec3(0.0, 0.0, 0.0);
620     #endif
621   }
622 #endif
623 struct StandardSurface {
624   vec4 albedo;
625   #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES
626   vec3 position, position_fract_part;
627   #else
628   vec3 position;
629   #endif
630   vec3 normal;
631   vec3 emissive;
632   vec3 lightmap;
633   float lightmap_test;
634   float roughness;
635   float metallic;
636   float occlusion;
637   float specularIntensity;
638   #if CC_RECEIVE_SHADOW
639     vec2 shadowBias;
640   #endif
641 };
642 vec4 CCStandardShadingBase (StandardSurface s, vec4 shadowPos) {
643   vec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);
644   vec3 specular = mix(vec3(0.08 * s.specularIntensity), s.albedo.rgb, s.metallic);
645   vec3 position;
646   #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES
647   position = unpackHighpData(s.position, s.position_fract_part);
648   #else
649   position = s.position;
650   #endif
651   vec3 N = normalize(s.normal);
652   vec3 V = normalize(cc_cameraPos.xyz - position);
653   float NV = max(abs(dot(N, V)), 0.0);
654   specular = BRDFApprox(specular, s.roughness, NV);
655   vec3 L = normalize(-cc_mainLitDir.xyz);
656   vec3 H = normalize(L + V);
657   float NH = max(dot(N, H), 0.0);
658   float NL = max(dot(N, L), 0.0);
659   vec3 finalColor = NL * cc_mainLitColor.rgb * cc_mainLitColor.w;
660   vec3 diffuseContrib = diffuse / PI;
661   vec3 specularContrib = specular * CalcSpecular(s.roughness, NH, H, N);
662   vec3 dirlightContrib = (diffuseContrib + specularContrib);
663   float shadow = 1.0;
664   #if CC_RECEIVE_SHADOW
665     if (NL > 0.0 && cc_mainLitDir.w > 0.0) {
666       shadow = CCShadowFactorBase(shadowPos, N, s.shadowBias);
667     }
668   #endif
669   dirlightContrib *= shadow;
670   finalColor *= dirlightContrib;
671   #if CC_USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD
672     if (s.lightmap_test > EPSILON_LOWP) {
673       finalColor = diffuse * s.lightmap.rgb * shadow;
674     }
675   #endif
676   float fAmb = 0.5 - N.y * 0.5;
677   vec3 ambDiff = mix(cc_ambientSky.rgb, cc_ambientGround.rgb, fAmb);
678   #if CC_USE_IBL
679     #if CC_USE_DIFFUSEMAP
680       vec4 diffuseMap = texture(cc_diffuseMap, N);
681       #if CC_USE_DIFFUSEMAP == 2
682         ambDiff = unpackRGBE(diffuseMap);
683       #else
684         ambDiff = SRGBToLinear(diffuseMap.rgb);
685       #endif
686     #endif
687     vec3 R = normalize(reflect(-V, N));
688     #if USE_REFLECTION_DENOISE
689       vec3 env = GetEnvReflectionWithMipFiltering(R, s.roughness, cc_ambientGround.w, 0.6);
690     #else
691       vec4 envmap = fragTextureLod(cc_environment, R, s.roughness * cc_ambientGround.w);
692       #if CC_USE_IBL == 2
693         vec3 env = unpackRGBE(envmap);
694       #else
695         vec3 env = SRGBToLinear(envmap.rgb);
696       #endif
697     #endif
698     finalColor += env * cc_ambientSky.w * specular * s.occlusion;
699   #endif
700   finalColor += ambDiff.rgb * cc_ambientSky.w * diffuse * s.occlusion;
701   finalColor += s.emissive;
702   return vec4(finalColor, s.albedo.a);
703 }
704 vec3 ACESToneMap (vec3 color) {
705   color = min(color, vec3(8.0));
706   const float A = 2.51;
707   const float B = 0.03;
708   const float C = 2.43;
709   const float D = 0.59;
710   const float E = 0.14;
711   return (color * (A * color + B)) / (color * (C * color + D) + E);
712 }
713 vec4 CCFragOutput (vec4 color) {
714   #if CC_USE_HDR
715     color.rgb = ACESToneMap(color.rgb);
716   #endif
717   color.rgb = sqrt(color.rgb);
718   return color;
719 }
720 in highp vec4 v_shadowPos;
721 #if CC_RECEIVE_SHADOW
722 #endif
723 #if CC_USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD
724   in vec3 v_luv;
725   uniform sampler2D cc_lightingMap;
726 #endif
727 in vec3 v_position;
728 in vec2 v_uv;
729 #if HAS_SECOND_UV
730   in mediump vec2 v_uv1;
731 #endif
732 in mediump vec3 v_normal;
733 #if CC_RECEIVE_SHADOW
734   in mediump vec2 v_shadowBias;
735 #endif
736 #if USE_VERTEX_COLOR
737   in lowp vec4 v_color;
738 #endif
739 #if USE_ALBEDO_MAP
740   uniform sampler2D albedoMap;
741 #endif
742 #if USE_NORMAL_MAP
743   in mediump vec4 v_tangent;
744   uniform sampler2D normalMap;
745 #endif
746 #if USE_PBR_MAP
747   uniform sampler2D pbrMap;
748 #endif
749 #if USE_METALLIC_ROUGHNESS_MAP
750   uniform sampler2D metallicRoughnessMap;
751 #endif
752 #if USE_OCCLUSION_MAP
753   uniform sampler2D occlusionMap;
754 #endif
755 #if USE_EMISSIVE_MAP
756   uniform sampler2D emissiveMap;
757 #endif
758 #if USE_ALPHA_TEST
759 #endif
760 void surf (out StandardSurface s) {
761   vec4 baseColor = albedo;
762   #if USE_VERTEX_COLOR
763     baseColor.rgb *= SRGBToLinear(v_color.rgb);
764     baseColor.a *= v_color.a;
765   #endif
766   #if USE_ALBEDO_MAP
767     vec4 texColor = texture(albedoMap, ALBEDO_UV);
768     texColor.rgb = SRGBToLinear(texColor.rgb);
769     baseColor *= texColor;
770   #endif
771   s.albedo = baseColor;
772   s.albedo.rgb *= albedoScaleAndCutoff.xyz;
773   #if USE_ALPHA_TEST
774     if (s.albedo.ALPHA_TEST_CHANNEL < albedoScaleAndCutoff.w) discard;
775   #endif
776   #if CC_USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD
777     vec4 lightColor = texture(cc_lightingMap, v_luv.xy);
778     s.lightmap = lightColor.xyz * v_luv.z;
779     s.lightmap_test = v_luv.z;
780   #endif
781   s.normal = v_normal;
782   #if CC_RECEIVE_SHADOW
783     s.shadowBias = v_shadowBias;
784   #endif
785   #if USE_NORMAL_MAP
786     vec3 nmmp = texture(normalMap, NORMAL_UV).xyz - vec3(0.5);
787     vec3 bitangent = cross(v_normal, v_tangent.xyz) * v_tangent.w;
788     s.normal =
789       (nmmp.x * emissiveScaleParam.w) * normalize(v_tangent.xyz) +
790       (nmmp.y * emissiveScaleParam.w) * normalize(bitangent) +
791       nmmp.z * normalize(s.normal);
792   #endif
793   #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES
794   packHighpData(s.position, s.position_fract_part, v_position);
795   #else
796   s.position = v_position;
797   #endif
798   vec4 pbr = pbrParams;
799   #if USE_PBR_MAP
800     vec4 res = texture(pbrMap, PBR_UV);
801     pbr.x *= res.r;
802     pbr.y *= res.g;
803     pbr.z *= res.b;
804     pbr.w *= res.a;
805   #endif
806   #if USE_METALLIC_ROUGHNESS_MAP
807     vec4 metallicRoughness = texture(metallicRoughnessMap, PBR_UV);
808     pbr.z *= metallicRoughness.b;
809     pbr.y *= metallicRoughness.g;
810   #endif
811   #if USE_OCCLUSION_MAP
812     pbr.x *= texture(occlusionMap, PBR_UV).r;
813   #endif
814   s.occlusion = pbr.x;
815   s.roughness = pbr.y;
816   s.specularIntensity = 0.5;
817   s.metallic = pbr.z;
818   s.emissive = emissive.rgb * emissiveScaleParam.xyz;
819   #if USE_EMISSIVE_MAP
820     s.emissive *= SRGBToLinear(texture(emissiveMap, EMISSIVE_UV).rgb);
821   #endif
822 }
823 #if CC_FORWARD_ADD
824   #if CC_PIPELINE_TYPE == 0
825     #define LIGHTS_PER_PASS 1
826   #else
827     #define LIGHTS_PER_PASS 10
828   #endif
829   #if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 0
830   layout(std140) uniform CCForwardLight {
831     highp vec4 cc_lightPos[LIGHTS_PER_PASS];
832     vec4 cc_lightColor[LIGHTS_PER_PASS];
833     vec4 cc_lightSizeRangeAngle[LIGHTS_PER_PASS];
834     vec4 cc_lightDir[LIGHTS_PER_PASS];
835   };
836   #endif
837   float SmoothDistAtt (float distSqr, float invSqrAttRadius) {
838     float factor = distSqr * invSqrAttRadius;
839     float smoothFactor = clamp(1.0 - factor * factor, 0.0, 1.0);
840     return smoothFactor * smoothFactor;
841   }
842   float GetDistAtt (float distSqr, float invSqrAttRadius) {
843     float attenuation = 1.0 / max(distSqr, 0.01*0.01);
844     attenuation *= SmoothDistAtt(distSqr , invSqrAttRadius);
845     return attenuation;
846   }
847   float GetAngleAtt (vec3 L, vec3 litDir, float litAngleScale, float litAngleOffset) {
848     float cd = dot(litDir, L);
849     float attenuation = clamp(cd * litAngleScale + litAngleOffset, 0.0, 1.0);
850     return (attenuation * attenuation);
851   }
852   #if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 0
853   vec4 CCStandardShadingAdditive (StandardSurface s, vec4 shadowPos) {
854     vec3 position;
855     #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES
856     position = unpackHighpData(s.position, s.position_fract_part);
857     #else
858     position = s.position;
859     #endif
860     vec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);
861     vec3 specular = mix(vec3(0.04), s.albedo.rgb, s.metallic);
862     vec3 diffuseContrib = diffuse / PI;
863     vec3 N = normalize(s.normal);
864     vec3 V = normalize(cc_cameraPos.xyz - position);
865     float NV = max(abs(dot(N, V)), 0.0);
866     specular = BRDFApprox(specular, s.roughness, NV);
867     vec3 finalColor = vec3(0.0);
868     int numLights = CC_PIPELINE_TYPE == 0 ? LIGHTS_PER_PASS : int(cc_lightDir[0].w);
869     for (int i = 0; i < LIGHTS_PER_PASS; i++) {
870       if (i >= numLights) break;
871       vec3 SLU = cc_lightPos[i].xyz - position;
872       vec3 SL = normalize(SLU);
873       vec3 SH = normalize(SL + V);
874       float SNL = max(dot(N, SL), 0.0);
875       float SNH = max(dot(N, SH), 0.0);
876       float distSqr = dot(SLU, SLU);
877       float litRadius = cc_lightSizeRangeAngle[i].x;
878       float litRadiusSqr = litRadius * litRadius;
879       float illum = litRadiusSqr / max(litRadiusSqr, distSqr);
880       float attRadiusSqrInv = 1.0 / max(cc_lightSizeRangeAngle[i].y, 0.01);
881       attRadiusSqrInv *= attRadiusSqrInv;
882       float att = GetDistAtt(distSqr, attRadiusSqrInv);
883       vec3 lspec = specular * CalcSpecular(s.roughness, SNH, SH, N);
884       if (cc_lightPos[i].w > 0.0) {
885         float cosInner = max(dot(-cc_lightDir[i].xyz, SL), 0.01);
886         float cosOuter = cc_lightSizeRangeAngle[i].z;
887         float litAngleScale = 1.0 / max(0.001, cosInner - cosOuter);
888         float litAngleOffset = -cosOuter * litAngleScale;
889         att *= GetAngleAtt(SL, -cc_lightDir[i].xyz, litAngleScale, litAngleOffset);
890       }
891       vec3 lightColor = cc_lightColor[i].rgb;
892       float shadow = 1.0;
893       #if CC_RECEIVE_SHADOW
894         if (cc_lightPos[i].w > 0.0 && cc_lightSizeRangeAngle[i].w > 0.0) {
895           shadow = CCSpotShadowFactorBase(shadowPos, position, s.shadowBias);
896         }
897       #endif
898       lightColor *= shadow;
899       finalColor += SNL * lightColor * cc_lightColor[i].w * illum * att * (diffuseContrib + lspec);
900     }
901     return vec4(finalColor, 0.0);
902   }
903   #endif
904   #if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 1
905   layout(std430, binding = 4) readonly buffer b_ccLightsBuffer { vec4 b_ccLights[]; };
906   layout(std430, binding = 5) readonly buffer b_clusterLightIndicesBuffer { uint b_clusterLightIndices[]; };
907   layout(std430, binding = 6) readonly buffer b_clusterLightGridBuffer { uvec4 b_clusterLightGrid[]; };
908   struct CCLight
909   {
910     vec4 cc_lightPos;
911     vec4 cc_lightColor;
912     vec4 cc_lightSizeRangeAngle;
913     vec4 cc_lightDir;
914   };
915   struct Cluster
916   {
917     vec3 minBounds;
918     vec3 maxBounds;
919   };
920   struct LightGrid
921   {
922     uint offset;
923     uint ccLights;
924   };
925   CCLight getCCLight(uint i)
926   {
927     CCLight light;
928     light.cc_lightPos = b_ccLights[4u * i + 0u];
929     light.cc_lightColor = b_ccLights[4u * i + 1u];
930     light.cc_lightSizeRangeAngle = b_ccLights[4u * i + 2u];
931     light.cc_lightDir = b_ccLights[4u * i + 3u];
932     return light;
933   }
934   LightGrid getLightGrid(uint cluster)
935   {
936     uvec4 gridvec = b_clusterLightGrid[cluster];
937     LightGrid grid;
938     grid.offset = gridvec.x;
939     grid.ccLights = gridvec.y;
940     return grid;
941   }
942   uint getGridLightIndex(uint start, uint offset)
943   {
944     return b_clusterLightIndices[start + offset];
945   }
946   uint getClusterZIndex(vec4 worldPos)
947   {
948     float scale = float(24) / log(cc_nearFar.y / cc_nearFar.x);
949     float bias = -(float(24) * log(cc_nearFar.x) / log(cc_nearFar.y / cc_nearFar.x));
950     float eyeDepth = -(cc_matView * worldPos).z;
951     uint zIndex = uint(max(log(eyeDepth) * scale + bias, 0.0));
952     return zIndex;
953   }
954   uint getClusterIndex(vec4 fragCoord, vec4 worldPos)
955   {
956     uint zIndex = getClusterZIndex(worldPos);
957     float clusterSizeX = ceil(cc_viewPort.z / float(16));
958     float clusterSizeY = ceil(cc_viewPort.w / float(8));
959     uvec3 indices = uvec3(uvec2(fragCoord.xy / vec2(clusterSizeX, clusterSizeY)), zIndex);
960     uint cluster = (16u * 8u) * indices.z + 16u * indices.y + indices.x;
961     return cluster;
962   }
963   vec4 CCClusterShadingAdditive (StandardSurface s, vec4 shadowPos) {
964     vec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);
965     vec3 specular = mix(vec3(0.04), s.albedo.rgb, s.metallic);
966     vec3 diffuseContrib = diffuse / PI;
967     vec3 position;
968     #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES
969     position = unpackHighpData(s.position, s.position_fract_part);
970     #else
971     position = s.position;
972     #endif
973     vec3 N = normalize(s.normal);
974     vec3 V = normalize(cc_cameraPos.xyz - position);
975     float NV = max(abs(dot(N, V)), 0.001);
976     specular = BRDFApprox(specular, s.roughness, NV);
977     vec3 finalColor = vec3(0.0);
978     uint cluster = getClusterIndex(gl_FragCoord, vec4(position, 1.0));
979     LightGrid grid = getLightGrid(cluster);
980     uint numLights = grid.ccLights;
981     for (uint i = 0u; i < 100u; i++) {
982       if (i >= numLights) break;
983       uint lightIndex = getGridLightIndex(grid.offset, i);
984       CCLight light = getCCLight(lightIndex);
985       vec3 SLU = light.cc_lightPos.xyz - position;
986       vec3 SL = normalize(SLU);
987       vec3 SH = normalize(SL + V);
988       float SNL = max(dot(N, SL), 0.001);
989       float SNH = max(dot(N, SH), 0.0);
990       float distSqr = dot(SLU, SLU);
991       float litRadius = light.cc_lightSizeRangeAngle.x;
992       float litRadiusSqr = litRadius * litRadius;
993       float illum = PI * (litRadiusSqr / max(litRadiusSqr , distSqr));
994       float attRadiusSqrInv = 1.0 / max(light.cc_lightSizeRangeAngle.y, 0.01);
995       attRadiusSqrInv *= attRadiusSqrInv;
996       float att = GetDistAtt(distSqr, attRadiusSqrInv);
997       vec3 lspec = specular * CalcSpecular(s.roughness, SNH, SH, N);
998       if (light.cc_lightPos.w > 0.0) {
999         float cosInner = max(dot(-light.cc_lightDir.xyz, SL), 0.01);
1000         float cosOuter = light.cc_lightSizeRangeAngle.z;
1001         float litAngleScale = 1.0 / max(0.001, cosInner - cosOuter);
1002         float litAngleOffset = -cosOuter * litAngleScale;
1003         att *= GetAngleAtt(SL, -light.cc_lightDir.xyz, litAngleScale, litAngleOffset);
1004       }
1005       vec3 lightColor = light.cc_lightColor.rgb;
1006       float shadow = 1.0;
1007       #if CC_RECEIVE_SHADOW
1008         if (light.cc_lightPos.w > 0.0) {
1009           shadow = CCSpotShadowFactorBase(shadowPos, position, s.shadowBias);
1010         }
1011       #endif
1012       lightColor *= shadow;
1013       finalColor += SNL * lightColor * light.cc_lightColor.w * illum * att * (diffuseContrib + lspec);
1014     }
1015     return vec4(finalColor, 0.0);
1016   }
1017   #endif
1018   layout(location = 0) out vec4 fragColorX;
1019   void main () {
1020     StandardSurface s; surf(s);
1021     #if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 1
1022     vec4 color = CCClusterShadingAdditive(s, v_shadowPos);
1023     #else
1024     vec4 color = CCStandardShadingAdditive(s, v_shadowPos);
1025     #endif
1026     fragColorX = CCFragOutput(color);
1027   }
1028 #elif (CC_PIPELINE_TYPE == 0 || CC_FORCE_FORWARD_SHADING)
1029   layout(location = 0) out vec4 fragColorX;
1030   void main () {
1031     StandardSurface s; surf(s);
1032     vec4 color = CCStandardShadingBase(s, v_shadowPos);
1033     CC_APPLY_FOG(color, s.position.xyz);
1034     fragColorX = CCFragOutput(color);
1035   }
1036 #elif CC_PIPELINE_TYPE == 1
1037   vec2 signNotZero(vec2 v) {
1038     return vec2((v.x >= 0.0) ? +1.0 : -1.0, (v.y >= 0.0) ? +1.0 : -1.0);
1039   }
1040   vec2 float32x3_to_oct(in vec3 v) {
1041     vec2 p = v.xy * (1.0 / (abs(v.x) + abs(v.y) + abs(v.z)));
1042     return (v.z <= 0.0) ? ((1.0 - abs(p.yx)) * signNotZero(p)) : p;
1043   }
1044   layout(location = 0) out vec4 fragColor0;
1045   layout(location = 1) out vec4 fragColor1;
1046   layout(location = 2) out vec4 fragColor2;
1047   void main () {
1048     StandardSurface s; surf(s);
1049     fragColor0 = s.albedo;
1050     fragColor1 = vec4(float32x3_to_oct(s.normal), s.roughness, s.metallic);
1051     fragColor2 = vec4(s.emissive, s.occlusion);
1052   }
1053 #endif
2022-07-08 13:36:49-error: [Scene] ERROR: 0:626: 'CC_PLATFORM_ANDROID_AND_WEBGL' : unexpected token after conditional expression
ERROR: 0:626: 'CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES' : unexpected token after conditional expression
ERROR: 0:647: 'CC_PLATFORM_ANDROID_AND_WEBGL' : unexpected token after conditional expression
ERROR: 0:647: 'CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES' : unexpected token after conditional expression
ERROR: 0:794: 'CC_PLATFORM_ANDROID_AND_WEBGL' : unexpected token after conditional expression
ERROR: 0:794: 'CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES' : unexpected token after conditional expression
ERROR: 0:856: 'CC_PLATFORM_ANDROID_AND_WEBGL' : unexpected token after conditional expression
ERROR: 0:856: 'CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES' : unexpected token after conditional expression
WARNING: 0:1054: '' : unexpected end of file found in directive
 
2022-07-08 13:36:50-log: [Im-plugin] No online info of im-plugin.
2022-07-08 13:37:14-warn: [Build] Browserslist: caniuse-lite is outdated. Please run:
npx browserslist@latest --update-db

Why you should do it regularly:
https://github.com/browserslist/browserslist#browsers-data-updating
2022-07-08 13:37:14-warn: [Build] Browserslist: caniuse-lite is outdated. Please run:
npx browserslist@latest --update-db
2022-07-08 13:37:16-warn: [Build] [[Build.Script.Rollup]] Use of eval is strongly discouraged, as it poses security risks and may cause issues with minification
2022-07-08 13:38:10-warn: [Build] [[Build.Script.Rollup]] Use of eval is strongly discouraged, as it poses security risks and may cause issues with minification
